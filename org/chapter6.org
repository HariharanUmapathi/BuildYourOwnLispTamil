* அத்தியாயம் 6 - பாகுபடுத்துதல் (Parsing)

** போலிஷ் குறிப்பு (Polish Notation)

mpc முயற்சிக்க, நாம் லிஸ்ப்பின் கணித துணைக்குழுவை (subset) ஒத்திருந்த எளிய
இலக்கணத்தை செயல்படுத்தப் போகிறோம். இது [[http://en.wikipedia.org/wiki/Polish_notation][போலிஷ் குறிப்பு]] என்று அழைக்கப்படுகிறது,
மேலும் இது இயக்கி (operator) செயல்பாட்டிற்கு (operands) முன் வரும்
எண்கணிதத்திற்கான குறிப்பு.

உதாரணத்திற்கு...

| 1 + 2 + 6          | is | + 1 2 6            |
| 6 + (2 * 9)        | is | + 6 (* 2 9)        |
| (10 * 2) / (4 + 2) | is | / (* 10 2) (+ 4 2) |

இந்த குறிப்பை விவரிக்கும் இலக்கணத்தை நாம் உருவாக்க வேண்டும். நாம் அதை உரையாக
(text) விவரிப்பதன் மூலம் தொடங்கலாம், பின்னர் நம் எண்ணங்களை முறைப்படுத்தலாம்.


தொடங்குவதற்கு, போலிஷ் குறிப்பிடில் செயலி (operator) எப்போதும் கோவையில்
(expression) முதலில் வருவதையும், அதைத் தொடர்ந்து அடைப்புக்குறிக்குள்
(parentheses) எண்கள் அல்லது பிற கோவை வருவதையும் நாம் பார்க்கலாம். இதன் பொருள்
"ஒரு நிரல் ஒரு செயலியைத் தொடர்ந்து ஒன்று அல்லது அதற்கு மேற்பட்ட கோவைகள்" என்று
கூறலாம், இதில் "ஒரு கோவை என்பது ஒரு எண் (number), அல்லது, அடைப்புக்குறிக்குள்,
ஒரு செயலியைத் தொடர்ந்து ஒன்று அல்லது அதற்கு மேற்பட்ட கோவைகள்" என்று கூறலாம்.

மேலும் முறைப்படி...


| Program    - நிரல்    | உள்ளீட்டின் தொடக்கத்தில், ஒரு செயலி (Operator), ஒன்று அல்லது அதற்கு மேற்பட்ட கோவை (Expression), மற்றும் முடிவில் உள்ளீடு. |
| Expression - கோவை | ஒரு எண் அல்லது '(', ஒரு செயலி, ஒன்று அல்லது அதற்கு மேற்பட்ட கோவை, மற்றும் ஒரு ')'.                                 |
| Operator   - செயலி  | '+', '-', '*', or '/'.                                                                                             |
| Number     -  எண்   | ஒரு விருப்பத்தேர்வு -, மற்றும் ஒன்று அல்லது அதற்கு மேற்பட்ட 0 மற்றும் 9 க்கு இடையில் உள்ள மதிப்புகள்                          |


** சுருங்குறித்தொடர் (Regular Expression)
ஏற்கனவே தெரிந்த விஷயங்களைப் பயன்படுத்தி மேலே உள்ள பெரும்பாலான விதிகளை
குறியாக்கம் செய்ய முடியும், ஆனால் எண் (Number) மற்றும் நிரல் (Program) சில
சிக்கலை ஏற்படுத்தக்கூடும். இந்த இரன்டையும் எப்படி வெளிப்படுத்துவது என்று இன்னும் நாம்
கற்றுக் கொள்ளவில்லை. உள்ளீட்டின் தொடக்கம் அல்லது எழுத்துகளின் வரம்பை எவ்வாறு
வெளிப்படுத்துவது என்பது நமக்கு தெரியாது.

இவற்றை வெளிப்படுத்தலாம், ஆனால் அவற்றுக்கு சுருங்குறித்தொடர் என்று ஒன்று
தேவைப்படுகிறது. சுருங்குறித்தொடர் என்பது சொற்கள் அல்லது எண்கள் போன்ற சிறிய
பகுதிகளுக்கு இலக்கணங்களை எழுதும் ஒரு வழியாகும். சுருங்குறித்தொடர்களைப்
பயன்படுத்தி எழுதப்பட்ட இலக்கணங்கள் பல விதிகளைக் கொண்டிருக்க முடியாது, ஆனால் அவை
பொருந்தக்கூடியவை மற்றும் பொருந்தாதவை பற்றிய துல்லியமான மற்றும் சுருக்கமான
கட்டுப்பாட்டைக் கொடுக்கின்றன. சுருங்குறித்தொடர் எழுதுவதற்கு சில அடிப்படை விதிகள்.

| .        | எதாவுது எழுத்து வேண்டும்.                        |
| a        | அ என்ற எழுத்து வேண்டும்.                       |
| [abcdef] | abcdef தொகுப்பில் எந்த எழுத்தும் வேண்டும்.        |
| [a-f]    | a முதல் f வரை உள்ள எந்த எழுத்தும் வேண்டும்       |
| a?       | a எழுத்து விருப்பமானது (optional).               |
| a*       | பூஜ்ஜியம் அல்லது அதற்கு மேற்பட்ட a எழுத்து தேவை. |
| a+       | ஒன்று அல்லது அதற்கு மேற்பட்ட a எழுத்துகள் தேவை. |
| \^       | உள்ளீட்டின் தொடக்கம் தேவை.                     |
| \$       | உள்ளீட்டின் முடிவு தேவை.                         |


இவையெல்லாம் இப்போது நமக்குத் தேவையான சுருங்குறித்தொடர்
விதிகள். சுருங்குறித்தொடர்கள் கற்றல் குறித்து முழு நூல்களும்
எழுதப்பட்டுள்ளன. ஆர்வமுள்ளவர்களுக்கு மேலும் தகவல்களை இணையத்தில் அல்லது இந்த
'ஆதாரங்களில்' காணலாம். அடுத்த அத்தியாயங்களில் அவற்றைப் பயன்படுத்துவோம், எனவே சில
அடிப்படை அறிமுகம் தேவைப்படும், ஆனால் நீங்கள் தற்போதைக்கு அதில் குருவாக மாற
வேண்டியதில்லை.

mpc இலக்கணத்தில் சுருங்குறித்தொடர்களை முன்னோக்கி சாய்வுகளுக்கு (forward slashes)
இடையில் வைத்து எழுதுகிறோம். மேலே உள்ள வழிகாட்டியைப் பயன்படுத்தி நாம் எண் விதியை
/-?[0-9]+/ என்ற சரத்தைப் பயன்படுத்தி சுருங்குறித்தொடர் என வெளிப்படுத்தலாம்.

** MPC ஐ நிறுவுதல் (Installing mpc)

இந்த இலக்கணத்தை எழுதுவதற்கு முன், நாம் முதலில் mpc தலைப்புகளைச் சேர்க்க வேண்டும்,
பின்னர் லினக்ஸ் மற்றும் மேக் இல் Editline போலவே mpc நூலகத்துடன் இணைக்க (link)
வேண்டும். அத்தியாயம் 4 இலிருந்து உங்கள் குறியீட்டில் தொடங்கி, நீங்கள் கோப்பை (file)
parsing.c என மறுபெயரிடலாம் (rename) மற்றும் mpc repo இலிருந்து mpc.h மற்றும்
mpc.c ஐப் பதிவிறக்கலாம். உங்கள் மூல கோப்பின் (source file) அதே கோப்பகத்தில்
(folder) இவற்றை வைக்கவும்.

mpc ஐ சேர்க்க கோப்பின் மேலே #include "mpc.h" ஐ வைக்கவும். mpc உடன் இணைக்க
mpc.c ஐ நேரடியாக நிரல்மொழிமாற்ற கட்டளையில் வைக்கவும். லினக்ஸில் நீங்கள் -lm ஐ
கொடி சேர்ப்பதன் மூலம் கணித நூலகத்துடன் (math library) இணைக்க வேண்டும்.

லினக்ஸ் மற்றும் மேக்கில்

#+begin_src shell
  cc -std=c99 -Wall parsing.c mpc.c -ledit -lm -o parsing
#+end_src

விண்டோஸில்

#+begin_src shell
  cc -std=c99 -Wall parsing.c mpc.c -o parsing
#+end_src

ஒரு நிமிடம், #include <mpc.h> என்று நீங்கள் எழுதவில்லையா ?

C இல் கோப்புகளைச் (file) சேர்க்க உண்மையில் இரண்டு வழிகள் உள்ளன. ஒன்று நாம் இதுவரை
பார்த்தபடி <> கோண அடைப்புக்குறிகளைப் (angular brackets) பயன்படுத்துகிறது,
மற்றொன்று மேற்கோள் குறிகளுடன் (quotation marks) "".

இரண்டிற்கும் இடையே உள்ள ஒரே வித்தியாசம் என்னவென்றால், கோண அடைப்புக்குறிகளைப்
பயன்படுத்தி முதலில் தலைப்புகளுக்கான அமைப்பு இருப்பிடங்களைத் (system location)
தேடுகிறது, அதே சமயம் மேற்கோள் குறிகள் தற்போதைய கோப்பகத்தை (current directory)
முதலில் தேடும். இந்த அமைப்பின் காரணமாக, <stdio.h> போன்ற தலைப்புகள் பொதுவாக கோண
அடைப்புக்குறிக்குள் வைக்கப்படுகின்றன, அதே நேரத்தில் "mpc.h" போன்ற உள்ளூர் தலைப்புகள்
பொதுவாக மேற்கோள் குறிகளில் வைக்கப்படுகின்றன.

** போலிஷ் குறியீட்டுமுறை இலக்கணம் (Polish Notation Grammar)

மேற்கூறிய விதிகளை மேலும் முறைப்படுத்தி, சில சுருங்குறித்தொடர்களைப் பயன்படுத்தி,
போலிஷ் குறியீட்டுமுறை மொழிக்கான இறுதி இலக்கணத்தை பின்வருமாறு எழுதலாம். கீழே உள்ள
குறியீட்டைப் படித்து, அது நாம் உரையாக எழுதியதற்கும், போலிஷ் குறியீட்டுமுறை பற்றிய
நம் யோசனைகளுக்கும் பொருந்துகிறதா என்பதைச் சரிபார்க்கவும்.

#+begin_src c
  /* சில பாகுபடுத்திகளை (parsers) உருவாக்க */
  mpc_parser_t* Number   = mpc_new("number");
  mpc_parser_t* Operator = mpc_new("operator");
  mpc_parser_t* Expr     = mpc_new("expr");
  mpc_parser_t* Lispy    = mpc_new("lispy");
  
  /* பின்வரும் மொழி மூலம் அவற்றை வரையறுக்கவும் */
  mpca_lang(MPCA_LANG_DEFAULT,
    "                                                     \
      number   : /-?[0-9]+/ ;                             \
      operator : '+' | '-' | '*' | '/' ;                  \
      expr     : <number> | '(' <operator> <expr>+ ')' ;  \
      lispy    : /^/ <operator> <expr>+ /$/ ;             \
    ",
    Number, Operator, Expr, Lispy);
  
#+end_src


இதை நாம் அத்தியாயம் 4ல் தொடங்கிய கலந்துரையாடல் தூண்டியில் (Interactive prompt)
சேர்க்க வேண்டும். இந்த குறியீட்டை முதன்மை (main) செயல்பாட்டின் (function)
தொடக்கத்தில் வைக்கவும், ~print the Version and Exit information~ முன்
வைக்கவும். நம் நிரலின் முடிவில், பாகுபடுத்திகளை பயன்படுத்தி முடித்ததும் அவற்றை
நீக்க வேண்டும். முதன்மை திரும்புவதற்கு (return) முன், பின்வரும் தூய்மைப்படுத்தல்
(clean up) குறியீட்டை வைக்க வேண்டும்.

#+begin_src c
  /* பாகுபடுத்திகளை வரையறுக்கப்படாதாக (undefine) மற்றி நீக்கவும் */
  mpc_cleanup(4, Number, Operator, Expr, Lispy);
#+end_src

- `mpc_lang' க்கு வரையறுக்கப்படவில்லை என்று ஒரு பிழையைப் பெறுகிறேன் ?
  - அது mpca_lang ஆக இருக்க வேண்டும், mpc இறுதியில் ஒரு ~a~

** பயனர் உள்ளீட்டைப் பாகுபடுத்துதல் (Parsing User Input)
<h2 id='parsing_user_input'>Parsing User Input</h2> <hr/>

<p>Our new code creates a <code>mpc</code> parser for our <em>Polish Notation</em> language, but we still need to actually <em>use</em> it on the user input supplied each time from the prompt. We need to edit our <code>while</code> loop so that rather than just echoing user input back, it actually attempts to parse the input using our parser. We can do this by replacing the call to <code>printf</code> with the following <code>mpc</code> code, that makes use of our program parser <code>Lispy</code>.</p>

<pre><code data-language='c'>/* Attempt to Parse the user Input */
mpc_result_t r;
if (mpc_parse("&lt;stdin&gt;", input, Lispy, &amp;r)) {
  /* On Success Print the AST */
  mpc_ast_print(r.output);
  mpc_ast_delete(r.output);
} else {
  /* Otherwise Print the Error */
  mpc_err_print(r.error);
  mpc_err_delete(r.error);
}</code></pre>

<p>This code calls the <code>mpc_parse</code> function with our parser <code>Lispy</code>, and the input string <code>input</code>. It copies the result of the parse into <code>r</code> and returns <code>1</code> on success and <code>0</code> on failure. We use the address of operator <code>&amp;</code> on <code>r</code> when we pass it to the function. This operator will be explained in more detail in later chapters.</p>

<p>On success an internal structure is copied into <code>r</code>, in the field <code>output</code>. We can print out this structure using <code>mpc_ast_print</code> and delete it using <code>mpc_ast_delete</code>.</p>

<p>Otherwise there has been an error, which is copied into <code>r</code> in the field <code>error</code>. We can print it out using <code>mpc_err_print</code> and delete it using <code>mpc_err_delete</code>.</p>

<p>Compile these updates, and take this program for a spin. Try out different inputs and see how the system reacts. Correct behaviour should look like the following.</p>

<pre><code data-language='lispy'>Lispy Version 0.0.0.0.2
Press Ctrl+c to Exit

lispy&gt; + 5 (* 2 2)
&gt;
  regex
  operator|char:1:1 '+'
  expr|number|regex:1:3 '5'
  expr|&gt;
    char:1:5 '('
    operator|char:1:6 '*'
    expr|number|regex:1:8 '2'
    expr|number|regex:1:10 '2'
    char:1:11 ')'
  regex
lispy&gt; hello
&lt;stdin&gt;:1:1: error: expected whitespace, '+', '-', '*' or '/' at 'h'
lispy&gt; / 1dog
&lt;stdin&gt;:1:4: error: expected one of '0123456789', whitespace, '-', one or more of one of '0123456789', '(' or end of input at 'd'
lispy&gt;</code></pre>

<div class="alert alert-warning">
  <p><strong>I'm getting an error <code>&lt;stdin&gt;:1:1: error: Parser Undefined!</code>.</strong></p>

  <p>This error is due to the syntax for your grammar supplied to <code>mpca_lang</code> being incorrect. See if you can work out what part of the grammar is incorrect. You can use the reference code for this chapter to help you find this, and verify how the grammar should look.</p>
</div>


<h2>Reference</h2> <hr/>

<references />

** வெகுமதி மதிப்பெண் (Bonus Marks)
<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&rsaquo; Write a regular expression matching strings of all <code>a</code> or <code>b</code> such as <code>aababa</code> or <code>bbaa</code>.</li>
    <li class="list-group-item">&rsaquo; Write a regular expression matching strings of consecutive <code>a</code> and <code>b</code> such as <code>ababab</code> or <code>aba</code>.</li>
    <li class="list-group-item">&rsaquo; Write a regular expression matching <code>pit</code>, <code>pot</code> and <code>respite</code> but <em>not</em> <code>peat</code>, <code>spit</code>, or <code>part</code>.</li>
    <li class="list-group-item">&rsaquo; Change the grammar to add a new operator such as <code>%</code>.</li>
    <li class="list-group-item">&rsaquo; Change the grammar to recognise operators written in textual format <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>.</li>
    <li class="list-group-item">&rsaquo; Change the grammar to recognize decimal numbers such as <code>0.01</code>, <code>5.21</code>, or <code>10.2</code>.</li>
    <li class="list-group-item">&rsaquo; Change the grammar to make the operators written conventionally, between two expressions.</li>
    <li class="list-group-item">&rsaquo; Use the grammar from the previous chapter to parse <code>Doge</code>. You must add <em>start</em> and <em>end</em> of input.</li>
  </ul>
</div>

<h2>Navigation</h2>

<table class="table" style='table-layout: fixed;'>
  <tr>
    <td class="text-left"><a href="chapter5_languages"><h4>&lsaquo; Languages</h4></a></td>
    <td class="text-center"><a href="contents"><h4>&bull; Contents &bull;</h4></a></td>
    <td class="text-right"><a href="chapter7_evaluation"><h4>Evaluation &rsaquo;</h4></a></td>
  </tr>
</table>
