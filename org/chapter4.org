* அத்தியாயம் 3 - கலந்துரையாடல் தூண்டி (Interactive Prompt)

** வாசிப்பு ,மதிப்பீடு, அச்சிடு (Read, Evaluate, Print)

நீங்கள் நிரலாக்க மொழியை உருவாக்கும்போது, ​​அதனுடன் கலந்துரையாடுவதற்கு சில வழிகள்
தேவைப்படும். சி ஒரு நிரல்மொழிமாற்றியை பயன்படுத்துகிறது, அங்கு நீங்கள் நிரலை
மாற்றி, அதை மீண்டும் நிரல்மொழிமாற்றி(recompile) இயக்கலாம். நாம் ஏதாவது சிறப்பாகச்
செய்து, மாறும் மொழியுடன் தொடர்பு கொண்டால் நன்றாக இருக்கும். அதன்பிறகு பல
நிபந்தனைகளின் கீழ் அதன் நடத்தையை மிக விரைவாகச் சோதிக்கிறோம். இதற்கு நாம்
கலந்துரையாடல் தூண்டி என்று ஒன்றை உருவாக்கலாம்.

இது சில உள்ளீட்டிற்கு பயனரைத் தூண்டும்(Prompts the user) ஒரு நிரலாகும், மேலும்
இது வழங்கப்படும் போது, ​​சில தகவல்களுடன் மீண்டும் பதிலளிக்கும். இதைப் பயன்படுத்துவது
மூலம் நமது நிரலாக்க மொழியைச் சோதிப்பதற்கும் அது எவ்வாறு செயல்படுகிறது என்பதைப்
பார்ப்பதற்கும் எளிதான வழியாகும். இந்த அமைப்பு REPL என்றும் அழைக்கப்படுகிறது, இது
வாசிப்பு-மதிப்பீடு-அச்சு சுழற்சியைக்(Read Evaluate Print Loop)
குறிக்கிறது. நிரலாக்க மொழியுடன் கலந்துரையாடுவதற்கு பொதுவாக இம்முறை
பயன்படுத்தபடுகிறது, நீங்கள் பைத்தானைப் போன்ற நிரல்மொழி பயன்படுத்தியிருந்தால்
அறிந்திருக்க வாய்ப்பு உண்டு.

முழு REPL ஐ உருவாக்குவதற்கு முன், எளிமையான ஒன்றைத் தொடங்குவோம். பயனரைத்
துண்டில்(User prompts) தந்த எந்த உள்ளீட்டையும் அதை நேராக எதிரொலிக்கும்(echo) ஒரு
அமைப்பை நாம் உருவாக்கப் போகிறோம். இதை நாம் உருவாக்கினால், பின்னர் பயனர் உள்ளீட்டைப்
பாகுபடுத்துவதற்கும்(Parse), உண்மையான லிஸ்ப்(Lisp) நிரலைப் போல மதிப்பிடுவதற்கும்
அதை நீட்டிக்கலாம்(Extend).

** ஒரு கலந்துரையாடல் தூண்டி (An Interactive Prompt)

அடிப்படையாக நாம் ஒரு சுழற்சியை(loop) எழுத வேண்டும், இது ஒரு தகவலை மீண்டும்
மீண்டும் எழுதுகிறது, பின்னர் சில உள்ளீடுகளுக்காக(input)
காத்திருக்கிறது. பயனர்(User) உள்ளீட்டைப் பெற, fgets எனப்படும் செயல்பாட்டைப்
பயன்படுத்தலாம், இது ஒரு புதிய வரி(New line) வரை எந்த உள்ளீட்டையும்
படிக்கும். இந்த பயனர் உள்ளீட்டைச் நாம் எங்காவது சேமிக்க வேண்டும். இதற்காக நாம்
நிலையான அளவு(Constantly sized) உள்ளீட்டு இடையகத்தை(Input buffer)
அறிவிக்கலாம்.

பயனர் உள்ளீடு சேமிக்கப்பட்டவுடன், printf எனப்படும் செயல்பாட்டைப்
பயன்படுத்தி பயனருக்கு மீண்டும் அச்சிடலாம்.

#+begin_src c
  #include <stdio.h>

  /* 2048 அளவு கொண்ட இடையகத்தை(Buffer) அல்லது அணி(Array), பயனர் உள்ளீட்டிற்காக அறிவிக்கவும் */
  static char input[2048];
  
  int main(int argc, char** argv) {
  
    /* பதிப்பை(version) அச்சிட்டு(print) வெளியேறவும் */
    puts("Lispy Version 0.0.0.0.1");
    puts("Press Ctrl+c to Exit\n");
  
    /* முடிவில்லாத சுழற்சியில் */
    while (1) {
  
      /* வெளியீட்டு தூண்டு (Output prompt) */
      fputs("lispy> ", stdout);
  
      /* அதிகபட்சம் 2048 அளவு கொண்ட பயனர் உள்ளீட்டின் வரியைப் படிக்கவும் */
      fgets(input, 2048, stdin);
  
      /* பயனருக்கு உள்ளீட்டை மீண்டும் அச்சிடவும் */
      printf("No you're a %s", input);
    }
  
    return 0;
  }
#+end_src

- அந்த //* *// இடையில் உள்ளை உரை என்ன செய்கிறது ?
  - மேலே உள்ள குறியீட்டில்(Code) விளக்கக்குறிப்பு(Comments) உள்ளது.
  - இவை //* *// குறியீடுகளுக்கு இடையே உள்ள குறியீட்டின் பிரிவுகள்
    (code section), அவை நிரல்மொழிமாற்றியல் புறக்கணிக்கப்படுகின்றன, ஆனால்
    என்ன நடக்கிறது என்பதைப் படிக்கும் நபருக்குத் தெரிவிக்கப் பயன்படுகிறது.
  - அவைகளை கவனிக்கவும்.

இந்த நிரலை இன்னும் கொஞ்சம் ஆழமாகப் பார்ப்போம்.

இந்த வரி static char input[2048]; 2048 எழுத்துக்கள் கொண்ட முழுதளாவிய
அணியை(global array) அறிவிக்கிறது. இது ஒரு ஒதுக்கப்பட்ட(reserved) தரவுத்
தொகுதியாகும்(Code blocks), இதை நம் நிரலில் இருந்து எங்கும் அணுகலாம். நாம்
இதில் கட்டளை வரியில் தட்டச்சு செய்யப்பட்ட பயனர் உள்ளீட்டை(User input) சேமிக்கப்
போகிறோம். Static சிறப்புச்சொல் இந்தக் கோப்பில் முழுதளாவிய மாறியை(global
variable) உருவாக்குகிறது, மேலும் [2048] பகுதி அளவை(size) அறிவிக்கும்.

நாம் while(1), வரை சுழற்சி(While loop) பயன்படுத்தி ஒரு முடிவிலா
சுழற்சியை(Infinite loop) எழுதுகிறோம். இதில் 1 என்று சுழற்சி அடைப்புக்குறிக்குள்
எழுதிரிகிறோம் அது நிபந்தனை உண்மை என்று அர்த்தம். எனவே இந்த சுழற்சியில் உள்ள
கட்டளைகள் எப்போதும் இயங்கும்.

நாம் தூண்டி வெளியிட, fputs செயல்பாட்டைப் பயன்படுத்துகிறோம். இது puts போல தான்
ஆனால் சிறிய மாறுபாடு புதிய வரி எழுத்தைச் சேர்க்காது. கட்டளை
வரியிலிருந்து(Command Prompt) பயனர் உள்ளீட்டைப் பெற fgets செயல்பாட்டைப்
பயன்படுத்துகிறோம். இந்த இரண்டு செயல்பாடுகளுக்கும் சில கோப்புகளை(File) எழுத
அல்லது படிக்க பயன்படுத்தப்படுகிறது. இதற்காக stdin மற்றும் stdout ஆகிய சிறப்பு
மாறிகளை பயன்படுத்துகிறோம். இவை <stdio.h> இல் அறிவிக்கப்பட்டு உள்ளது,இது கட்டளை
வரியில் இருந்து உள்ளீடு மற்றும் வெளியீட்டைக் குறிக்கும் சிறப்பு கோப்பு மாறிகள்
ஆகும். இந்த மாறியை fgets செயல்பாடுகு அளபுருக(Parameter) கூடுதல் அது பயனர்
உரையின் வரியை உள்ளிடுவதற்கு காத்திருக்கும், உள்ளீட்டு வந்தபின் அதை
இடையகத்தில்(Buffer) புதிய வரி எழுத்துடன் சேர்த்து சேமிக்கும். fgets அதிக
தரவுகளைப் படிக்காதபடி இருக்க, இடையக(Buffer) 2048 என்ற அளவையும் வழங்க வேண்டும்.

பயனருக்கு செய்தியை எதிரொலிக்க நாம் printf செயல்பாட்டைப் பயன்படுத்துகிறோம். இது
பல கூறுகளைக்(elements) கொண்ட செய்திகளை அச்சிடுவதற்கான வழியை வழங்கும் ஒரு
செயல்பாடாகும். கொடுக்கப்பட்ட சரத்தில் உள்ள மாதிரிக்கு(pattern)
தருமதிப்பு(arguments) பொருந்துகிறது. எடுத்துக்காட்டாக, கொடுக்கப்பட்ட சரத்தில் %s
மாதிரியைக் காணலாம். அதாவது, அடுத்ததாக எந்த தருமதிப்பு அனுப்பப்பட்டாலும், அது
ஒரு சரமாக விளக்கப்படும்.

இந்த வெவ்வேறு மாதிரிகள் பற்றிய கூடுதல் தகவலுக்கு, printf இல் உள்ள [[http://en.cppreference.com/w/c/io/printf][ஆவணங்களைப்]]
பார்க்கவும்.

- fgets மற்றும் printf போன்ற செயல்பாடுகளை பற்றி நான் எப்படி தெரிந்து கொள்ள வேண்டும்?
  - இந்த நிலையான செயல்பாடுகளைப் பற்றி எப்படி அறிந்து கொள்வது, எப்போது அவற்றைப்
    பயன்படுத்துவது என்பது உடனடியாகத் தெரியாது. ஒரு சிக்கலை எதிர்கொள்ளும் போது,
    ​​நூலக செயல்பாடுகளால் அது ஏற்கனவே தீர்க்கப்பட்டது என்பதை அறிய அனுபவம் தேவை.
  - அதிர்ஷ்டவசமாக சி ஒரு சிறிய நிலையான நூலகத்தைக் கொண்டுள்ளது மற்றும் கிட்டத்தட்ட
    அனைத்தையும் நடைமுறையில் கற்றுக்கொள்ளலாம். நீங்கள் மிகவும் அடிப்படையான அல்லது
    அடிப்படையானதாகத் தோன்றும் ஒன்றைச் செய்ய விரும்பினால், நிலையான நூலகத்திற்கான
    குறிப்பு [[https://en.cppreference.com/w/c][ஆவணங்களைப்]] பார்த்து, நீங்கள் விரும்பியதைச் செய்யும் செயல்பாடுகள் ஏதேனும்
    உள்ளதா எனச் சரிபார்க்க வேண்டும்.

** நிரல்மொழிமாற்றுதல் (Compilation)

இரண்டாவது அத்தியாயத்தில் பயன்படுத்தப்பட்ட அதே கட்டளையுடன் இதை நீங்கள்
நிரல்மொழிமாற்றலாம்.

#+begin_src shell
  cc -std=c99 -Wall prompt.c -o prompt
#+end_src

இதை நிரல்மொழிமாற்றிய பிறகு நீங்கள் இதை இயக்க முயற்சிக்க வேண்டும். முடித்ததும்
நிரலிலிருந்து வெளியேற Ctrl+c ஐப் பயன்படுத்தலாம். எல்லாம் சரியாக இருந்தால், உங்கள்
நிரல் கீழே உள்ளதைப் போல இருக்க வேண்டும்.

#+begin_example
Lispy Version 0.0.0.0.1
Press Ctrl+c to Exit

lispy> hello
No you're a hello
lispy> my name is Dan
No you're a my name is Dan
lispy> Stop being so rude!
No you're a Stop being so rude!
lispy>
#+end_example

** உள்ளீடு திருத்துதல் (Editing Input)
நீங்கள் லினக்ஸ்(Linux) அல்லது மேக்(Mac) இல் பயன்படுத்துகிறீர்கள் என்றால், உங்கள்
உள்ளீட்டைத் திருத்துவதற்கு அம்புக்குறி விசைகளைப்(Arrow Keys) பயன்படுத்தும்போது சில
வித்தியாசமான நடத்தைகளைக் காண்பீர்கள்.

#+begin_example
Lispy Version 0.0.0.0.3
Press Ctrl+c to Exit

lispy> hel^[[D^[[C
#+end_example

அம்புக்குறி விசைகளைப் பயன்படுத்தும்போது, உள்ளீட்டில் காட்டியை(Cursor)
நகர்த்துவதற்குப் பதிலாக, இந்த வித்தியாசமான எழுத்துக்களை ^[[D அல்லது ^[[C
உருவாக்குகிறது. நாம் உண்மையில் விரும்புவது என்னவென்றால், வரியில் சுற்றிச்
நகர(Move around the line), நாம் தவறு செய்தால் உள்ளீட்டை நீக்குதல் மற்றும்
திருத்துதல்.

விண்டோஸில் இந்த நடத்தை இயல்புநிலையாகும். லினக்ஸ் மற்றும் மேக்கில் இது Editline
எனப்படும் நூலகத்தால் வழங்கப்படுகிறது. லினக்ஸ் மற்றும் மேக்கில், இந்த நூலகம் வழங்கும்
செயல்பாடுகளுக்கான அழைப்புகளை fputs மற்றும் fgetsக்கு மாற்றாக பயன்படுத்துத
வேண்டும்.

நீங்கள் விண்டோஸில் உருவாக்கினால், அடுத்த சில பகுதிகள் பொருத்தமானதாக இருக்காது
என்பதால், இந்த அத்தியாயத்தின் இறுதிக்கு செல்லவும்.

*** Editline பயன்படுத்துதல்
<h3>Using Editline</h3>

<p>The library <code>editline</code> provides two functions we are going to use called <code>readline</code> and <code>add_history</code>. This first function, <code>readline</code> is used to read input from some prompt, while allowing for editing of that input. The second function <code>add_history</code> lets us record the history of inputs so that they can be retrieved with the up and down arrows.</p>

<p>We replace <code>fputs</code> and <code>fgets</code> with calls to these functions to get the following.</p>

<pre><code data-language='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;editline/readline.h&gt;
#include &lt;editline/history.h&gt;

int main(int argc, char** argv) {

  /* Print Version and Exit Information */
  puts("Lispy Version 0.0.0.0.1");
  puts("Press Ctrl+c to Exit\n");

  /* In a never ending loop */
  while (1) {

    /* Output our prompt and get input */
    char* input = readline("lispy&gt; ");

    /* Add input to history */
    add_history(input);

    /* Echo input back to user */
    printf("No you're a %s\n", input);

    /* Free retrieved input */
    free(input);

  }

  return 0;
}</code></pre>

<p>We have <em>included</em> a few new <em>headers</em>. There is <code>#include &lt;stdlib.h&gt;</code>, which gives us access to the <code>free</code> function used later on in the code. We have also added <code>#include &lt;editline/readline.h&gt;</code> and <code>#include &lt;editline/history.h&gt;</code> which give us access to the <code>editline</code> functions, <code>readline</code> and <code>add_history</code>.</p>

<p>Instead of prompting, and getting input with <code>fgets</code>, we do it in one go using <code>readline</code>. The result of this we pass to <code>add_history</code> to record it. Finally we print it out as before using <code>printf</code>.</p>

<p>Unlike <code>fgets</code>, the <code>readline</code> function strips the trailing newline character from the input, so we need to add this to our <code>printf</code> function. We also need to delete the input given to us by the <code>readline</code> function using <code>free</code>. This is because unlike <code>fgets</code>, which writes to some existing buffer, the <code>readline</code> function allocates new memory when it is called. When to free memory is something we cover in depth in later chapters.</p>

*** Compiling with Editline (translate to tamil)
<h3>Compiling with Editline</h3>

<p>If you try to compile this right away with the previous command you'll get an error. This is because you first need to install the <code>editline</code> library on your computer.</p>

<pre><code>fatal error: editline/readline.h: No such file or directory #include &lt;editline/readline.h&gt;</code></pre>

<p>On <strong>Mac</strong> the <code>editline</code> library comes with <em>Command Line Tools</em>. Instructions for installing these can be found in <a href="http://www.buildyourownlisp.com/chapter2_installation">Chapter 2</a>. You may still get an error about the history header not being found. In this case remove the line <code>#include &lt;editline/history.h&gt;</code>, as this header may not be required.</p>

<p>On <strong>Linux</strong> you can install <em>editline</em> with <code>sudo apt-get install libedit-dev</code>. On Fedora you can use the command <code>su -c "yum install libedit-dev*"</code></p>

<p>Once you have installed <em>editline</em> you can try to compile it again. This time you'll get a different error.</p>

<pre><code>undefined reference to `readline'
undefined reference to `add_history'
</code></pre>

<p>This means that you haven't <em>linked</em> your program to <code>editline</code>. This <em>linking</em> process allows the compiler to directly embed calls to <code>editline</code> in your program. You can make it link by adding the flag <code>-ledit</code> to your compile command, just before the output flag.</p>

<pre><code>cc -std=c99 -Wall prompt.c -ledit -o prompt</code></pre>

<p>Run it and check that now you can edit inputs as you type them in.</p>

<div class="alert alert-warning">
  <p><strong>It's still not working!</strong></p>
  
  <p>Some systems might have slight variations on how to install, include, and link to <code>editline</code>. For example on Arch linux the editline history header is <code>histedit.h</code>. If you are having trouble search online and see if you can find distribution specific instructions on how to install and use the <code>editline</code> library. If that fails search for instructions on the <code>readline</code> library. This is a drop-in replacement for editline. On Mac it can be installed using HomeBrew or MacPorts.</p>
</div>

** சி முன்செயலி (The C Preprocessor)

<h2 id='the_c_preprocessor'>The C Preprocessor</h2> <hr/>

<p>For such a small project it might be okay that we have to program differently depending on what operating system we are using, but if I want to send my source code to a friend on a different operating system to give me a hand with the programming, it is going to cause problems. In an ideal world I'd wish for my source code to be able to compile no matter where, or on what computer, it is being compiled. This is a general problem in C, and it is called <em>portability</em>. There is not always an easy or correct solution.</p>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/octopus.png" alt="octopus" class="img-responsive" width="266px" height="268px"/>
  <p><small>Octopus &bull; Sort of like Octothorpe</small></p>
</div>

<p>But C does provide a mechanism to help, called <em>the preprocessor</em>.</p>

<p>The preprocessor is a program that runs before the compiler. It has a number of purposes, and we've been actually using it already without knowing. Any line that starts with a octothorpe <code>#</code> character (hash to you and me) is a preprocessor command. We've been using it to <em>include</em> header files, giving us access to functions from the standard library and others.</p>

<p>Another use of the preprocessor is to detect which operating system the code is being compiled on, and to use this to emit different code.</p>

<p>This is exactly how we are going to use it. If we are running Windows we're going to let the preprocessor emit code with some fake <code>readline</code> and <code>add_history</code> functions I've prepared, otherwise we are going to include the headers from <code>editline</code> and use these.</p>

<p>To declare what code the compiler should emit we can wrap it in <code>#ifdef</code>, <code>#else</code>, and <code>#endif</code> preprocessor statements. These are like an <code>if</code> function that happens before the code is compiled. All the contents of the file from the first <code>#ifdef</code> to the next <code>#else</code> are used if the condition is true, otherwise all the contents from the <code>#else</code> to the final <code>#endif</code> are used instead. By putting these around our fake functions, and our editline headers, the code that is emitted should compile on Windows, Linux or Mac.</p>

<pre><code data-language='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* If we are compiling on Windows compile these functions */
#ifdef _WIN32
#include &lt;string.h&gt;

static char buffer[2048];

/* Fake readline function */
char* readline(char* prompt) {
  fputs(prompt, stdout);
  fgets(buffer, 2048, stdin);
  char* cpy = malloc(strlen(buffer)+1);
  strcpy(cpy, buffer);
  cpy[strlen(cpy)-1] = '\0';
  return cpy;
}

/* Fake add_history function */
void add_history(char* unused) {}

/* Otherwise include the editline headers */
#else
#include &lt;editline/readline.h&gt;
#include &lt;editline/history.h&gt;
#endif

int main(int argc, char** argv) {

  puts("Lispy Version 0.0.0.0.1");
  puts("Press Ctrl+c to Exit\n");

  while (1) {

    /* Now in either case readline will be correctly defined */
    char* input = readline("lispy&gt; ");
    add_history(input);

    printf("No you're a %s\n", input);
    free(input);

  }

  return 0;
}</code></pre>

** குறிப்பு (Reference)
<h2>Reference</h2> <hr/>

<references />

** வெகுமதி மதிப்பெண் (Bonus Marks)
<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
<ul class="list-group">
  <li class="list-group-item">&rsaquo; Change the prompt from <code>lispy&gt;</code> to something of your choice.</li>
  <li class="list-group-item">&rsaquo; Change what is echoed back to the user.</li>
  <li class="list-group-item">&rsaquo; Add an extra message to the <em>Version</em> and <em>Exit</em> Information.</li>
  <li class="list-group-item">&rsaquo; What does the <code>\n</code> mean in those strings?</li>
  <li class="list-group-item">&rsaquo; What other patterns can be used with <code>printf</code>?</li>
  <li class="list-group-item">&rsaquo; What happens when you pass <code>printf</code> a variable that does not match the pattern?</li>
  <li class="list-group-item">&rsaquo; What does the preprocessor command <code>#ifndef</code> do?</li>
  <li class="list-group-item">&rsaquo; What does the preprocessor command <code>#define</code> do?</li>
  <li class="list-group-item">&rsaquo; If <code>_WIN32</code> is defined on windows, what is defined for Linux or Mac?</li>
</ul>
</div>
