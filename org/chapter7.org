* அத்தியாயம் 7 - மதிப்பீடு (Evaluation)

** மரவுரு (Trees)

இப்போது நாம் உள்ளீட்டைப் (input) படித்து, அதை உள் கட்டமைத்துள்ளோம் (structured
internally), ஆனால் அதை இன்னும் மதிப்பீடு செய்ய முடியவில்லை. இந்த அத்தியாயத்தில்
அந்த கட்டமைப்பை மதிப்பிடும் குறியீடு சேர்ப்போம் மற்றும் கணக்கீடுகளை (computation)
நிகழ்த்துவோம்.

இந்த உள் கட்டமைப்புதான் முந்தைய அத்தியாயத்தில் நிரல் மூலம் அச்சிடப்பட்டதைப்
பார்த்தோம். இது ஒரு கருத்தியல் தொடரமைப்பு மரவுரு (Abstract Syntax Tree) என்று
அழைக்கப்படுகிறது, மேலும் இது பயனர் உள்ளீட்டின் அடிப்படையில் நிரலின் கட்டமைப்பைக்
குறிக்கிறது. இந்த மரத்தின் இலைகளில் எண்கள் மற்றும் செயலி (Operator) உள்ளன -
செயலாக்கப்பட வேண்டிய தரவு. கிளைகளில் மரத்தின் இந்தப் பகுதியை உற்பத்தி செய்யப்
பயன்படுத்தப்படும் விதிகள் உள்ளன - அதை எவ்வாறு கடந்து செல்வது (Traverse) மற்றும்
மதிப்பிடுவது (Evaluate) என்பது பற்றிய தகவல்கள்.

இதை எப்படி கடந்து செல்ல போகிறோம் என்பதைச் சரியாகச் செய்வதற்கு முன், இந்த அமைப்பு
எவ்வாறு உள் வரையறுக்கப்படுகிறது (internally defined) என்பதைப் பார்ப்போம். நாம்
mpc.h இன் உள்ளே எட்டிப்பார்த்தால், mpc_ast_t இன் வரையறையைப் (definition)
பார்க்கலாம், இது பாகுபாட்டிலிருந்து நமக்குக் கிடைத்த தரவுக் கட்டமைப்பாகும் (Data
structure).

#+begin_src c
  typedef struct mpc_ast_t {
    char* tag;
    char* contents;
    mpc_state_t state;
    int children_num;
    struct mpc_ast_t** children;
  } mpc_ast_t;
#+end_src

இந்த கட்டமைப்பில் நாம் அணுகக்கூடிய பல புலங்கள் (fields) உள்ளன. அவற்றை ஒவ்வொன்றாகப்
பார்ப்போம்.

முதல் புலம் (field) ~tag~. நாம் மரவுருவை (tree) அச்சிட்டபோது அது முனையின்
உள்ளடக்கத்திற்கு (contents) முந்தைய தகவல். அது குறிப்பிட்ட உருப்படியை (item)
பாகுபடுத்த பயன்படுத்தப்படும் அனைத்து விதிகளின் பட்டியலைக் கொண்ட ஒரு
சரம். உதாரணமாக expr|number|regex.

முனையை உருவாக்க என்ன பாகுபடுத்தும் விதிகள் பயன்படுத்தப்பட்டுள்ளன என்பதை அறிய,
இந்தக் ~tag~ புலம் முக்கியமானதாக இருக்கும்.

இரண்டாவது புலம் ~contents~. இது '*', '(' அல்லது '5' போன்ற முனையின் உள்ளபடி
உள்ளடக்கங்களைக் கொண்டிருக்கும். கிளைகளில் (branch) இது காலியாக இருப்பதை நீங்கள்
கவனிப்பீர்கள், ஆனால் இலைகளுக்குப் (leaf) பயன்படுத்துவதற்கான செயலி (operator)
அல்லது எண்ணைக் கண்டறிய இதைப் பயன்படுத்தலாம்.

அடுத்த புலம் ~state~. வரி மற்றும் நெடுவரிசை (column) எண் போன்ற இந்தக் கணுவைக்
(node) கண்டறிந்த போது பாகுபடுத்தி எந்த நிலையில் இருந்தது என்பது பற்றிய தகவல்
இதில் உள்ளது. நமது திட்டத்தில் (project) இதைப் பயன்படுத்த மாட்டோம்.

இறுதியாக மரவுருவில் கடந்து செல்ல உதவும் இரண்டு புலம்களைப் பார்க்கிறோம். இவை
~children_num~ மற்றும் ~children~. முதல் புலம் ஒரு கணுவுக்கு (node) எத்தனை
குழந்தைகள் என்று சொல்கிறது, இரண்டாவது இந்த குழந்தைகளின் அணி (Array).

~children~ புலத்தின் வகை mpc_ast_t**. இது இரட்டை சுட்டி வகை ஆகும். இது
தோற்றமளிப்பது போல் பயமாக இருக்காது மற்றும் அடுத்த அத்தியாயங்களில் இன்னும் விரிவாக
விளக்கப்படும். இப்போதைக்கு இதை இந்த மரவுருவின் குழந்தை கணுகளின் (node) பட்டியல்
(list) என்று நினைக்கலாம்.

அணி குறிமான முறையைப் (notation) பயன்படுத்தி இந்த புலத்தை அணுகுவதன் மூலம் நாம்
குழந்தை கணுவை (node) அணுகலாம். children என்ற புலப் பெயரை எழுதி, அதை
அணுகுவதற்கு குழந்தையின் சுட்டெண் (index) கொண்ட சதுர அடைப்புக்குறிகளுடன் (square
brackets) பின்னொட்டு (suffix) இடுவதன் மூலம் இது செய்யப்படுகிறது. உதாரணமாக
கணுவின் முதல் குழந்தையை அணுக நாம் children[0] என்று பயன்படுத்தலாம். சி அதன் அணி
சுட்டெண்களை (indices) 0 இலிருந்து கணக்கிடுகிறது என்பதைக் கவனியுங்கள்.

mpc_ast_t* வகை ஒரு structக்கான சுட்டிக்காட்டி என்பதால், அதன் புலங்களை (fields) அணுகுவதற்கு சற்று வித்தியாசமான தொடரியல் (syntax) உள்ளது. நாம் ஒரு புள்ளிக்குப் (dot .) பதிலாக ஒரு அம்புக்குறியைப் (arrow ->) பயன்படுத்த வேண்டும் இந்த செயலி (operator) மாறுதலுக்கு அடிப்படைக் காரணம் எதுவும் இல்லை, எனவே இப்போது சுட்டிக்காட்டி வகைகளின் புல (field) அணுகல் அம்புக்குறியைப் பயன்படுத்துகிறது என்பதை நினைவில் கொள்ளுங்கள்.

#+begin_src c
  /* வெளியீட்டிலிருந்து AST ஐ ஏற்றவும் */
mpc_ast_t* a = r.output;
printf("Tag: %s\n", a->tag);
printf("Contents: %s\n", a->contents);
printf("Number of children: %i\n", a->children_num);

/* முதல் குழந்தையைப் எடுங்கள் */
mpc_ast_t* c0 = a->children[0];
printf("First Child Tag: %s\n", c0->tag);
printf("First Child Contents: %s\n", c0->contents);
printf("First Child Number of children: %i\n",
  c0->children_num);
#+end_src

** தானழைப்பு (Recursion)

இந்த மரவுரு அமைப்பில் ஒரு வித்தியாசமான விஷயம் உள்ளது. அது தன்னையே குறிக்கிறது. அதன் ஒவ்வொரு குழந்தைகளும் மீண்டும் மரவுருக்களை குறிக்கும், அந்த குழந்தைகளின் குழந்தைகள் மீண்டும் மரவுருக்களை குறிக்கின்றது. நம் மொழிகள் மற்றும் மீண்டும் எழுதும் விதிகளைப் (re-write rules) போலவே, இந்தக் கட்டமைப்பில் (structure) உள்ள தரவு (data), அவர்களின் பெற்றோரை ஒத்த துணையமைப்புகளை (substructure) மீண்டும் கொண்டுள்ளது.

இந்த அமைப்பு (pattern) மீண்டும் மீண்டும் துணையமைப்புகளில் தொடரலாம். சாத்தியமான அனைத்து மரவுருக்களிலும் வேலை செய்யக்கூடிய ஒரு செயல்பாட்டை நாம் விரும்பினால், நாம் ஒரு ஜோடி கணுக்களை (nodes) மட்டும் கீழே பார்க்க முடியாது. மரவுருக்கள் எந்த ஆழத்திலும் வேலை செய்ய நாம் அதை வரையறுக்க (define) வேண்டும்.

அதிர்ஷ்டவசமாக, இந்த துணையமைப்புகள் எவ்வாறு மீண்டும் மீண்டும் வருகின்றன என்பதன் இயல்புகளைப் பயன்படுத்தி, தானழைப்பு (recursion) எனப்படும் வழிமுறையைப் பயன்படுத்துவதன் மூலம் இதைச் செய்யலாம்.

எளிமையாகச் சொன்னால், தானழைப்பு செயல்பாடு என்பது அதன் கணக்கீட்டின் (calculation) ஒரு பகுதியாக தன்னை அழைக்கும் ஒன்றாகும்.

ஒரு செயல்பாடு அதன் அடிப்படையில் வரையறுக்கப்படுவது விசித்திரமாகத் தெரிகிறது. ஆனால் செயல்பாடுகள் வெவ்வேறு உள்ளீடுகளுடன் வழங்கும்போது வெவ்வேறு வெளியீடுகளைக் கொடுக்க முடியும் என்பதைக் கவனியுங்கள். தானழைப்புக்கு மாற்றப்பட்ட அல்லது வெவ்வேறு உள்ளீடுகளை அதே செயல்பாட்டிற்கு வழங்கினால், மேலும் சில நிபந்தனைகளின் (conditions) கீழ் இந்தச் செயல்பாடு தன்னை மீண்டும் அழைக்காமல் இருப்பதற்கான வழியை வழங்கினால், இந்த தானழைப்பு செயல்பாடு பயனுள்ள ஒன்றைச் செய்கிறது என்பதில் நாம் அதிக நம்பிக்கையுடன் இருக்கலாம்.

தொடங்குவதற்கு முன், இது மிகவும் எளிமையான வழக்கில் எவ்வாறு செயல்படும் என்பதை நாம் கண்டுபிடிப்போம் - உள்ளீடு (input) மரவுருக்கு குழந்தைகள் இல்லை என்றால். இந்த விஷயத்தில் முடிவு ஒன்றுதான் என்பதை நாம் அறிவோம். இப்போது நாம் மிகவும் சிக்கலான வழக்கை வரையறுக்கலாம் - மரவுருவுக்கு ஒன்று அல்லது அதற்கு மேற்பட்ட குழந்தைகள் இருந்தால். இந்த வழக்கில் முடிவு ஒன்றாக இருக்கும் (கணுக்காகவே), அதனுடன் சேர்த்து அந்தக் குழந்தைகளில் உள்ள கணுக்களின் எண்ணிக்கை.

ஆனால் எல்லா குழந்தைகளிலும் உள்ள கணுக்களின் எண்ணிக்கையை எப்படி கண்டுபிடிப்பது? சரி நாம் வரையறுக்கும் செயல்பாட்டில் இருக்கும் செயல்பாட்டைப் பயன்படுத்தலாம்! ஆமாம், தானழைப்பு.

சி இல் நாம் இதை இப்படி எழுதலாம்.

#+begin_src c
int number_of_nodes(mpc_ast_t* t) {
  if (t->children_num == 0) { return 1; }
  if (t->children_num >= 1) {
    int total = 1;
    for (int i = 0; i < t->children_num; i++) {
      total = total + number_of_nodes(t->children[i]);
    }
    return total;
  }
  return 0;
}
#+end_src

தானழைப்பு செயல்பாடுகள் வித்தியாசமானவை, ஏனென்றால் அவற்றுக்கு கொஞ்சம் முரணான
நம்பிக்கை தேவை. முதலில் நாம் யூகிக்க வேண்டும் நம்மிடம் ஒரு செயல்பாடு உள்ளது, அது
ஏற்கனவே எதையாவது சரியாகச் செய்கிறது. பின்னர் இந்த செயல்பாட்டைப் பயன்படுத்தி, நாம்
நினைத்த ஆரம்ப (initial) செயல்பாட்டை எழுத வேண்டும்!

பெரும்பாலான விஷயங்களைப் போலவே, தானழைப்பு செயல்பாடுகளும் எப்போதும் ஒரே
மாதிரியான முறையைப் பின்பற்றுகின்றன. முதலில் ஒரு அடிப்படை நிலை (Base case)
வரையறுக்கப்படுகிறது. நமது முந்தைய எடுத்துக்காட்டில் t->children_num == 0 என்ற
நிலை (case) தானழைப்பை முடிவடைய செய்யும். இதற்குப் பிறகு, தானழைப்பு நிலை
(recursive case) வரையறுக்கப்படுகிறது, t->children_num >= 1 போன்று நமது
முந்தைய எடுத்துக்காட்டில், இது ஒரு கணக்கீட்டை சிறிய பகுதிகளாக உடைத்து, அவற்றை
ஒன்றாக இணைக்கும் முன், அந்த பகுதிகளை கணக்கிடுவதற்கு தன்னைத்தானே திரும்பத் திரும்ப
அழைக்கிறது.

தானழைப்பு செயல்பாடு புரிந்து கொள்வதற்கு சிறிது கணம் அகலம், எனவே இப்போது
இடைநிறுத்தப்பட்டு (pause), மற்ற அத்தியாயங்களில் தொடர்வதற்கு முன் அவற்றைப்
புரிந்துகொள்வதை உறுதிசெய்து கொள்ளுங்கள், ஏனென்றால் புத்தகத்தின் மற்ற பகுதிகளில்
அவற்றை நாம் அதிகமாக பயன்படுத்துவோம். நீங்கள் இன்னும் தானழைப்பில் உறுதியில்லாதவராக
இருந்தால், இந்த அத்தியாயத்திற்கான வெகுமதி மதிப்பெண்களில் (Bonus mark section)
சிலவற்றை முயற்சிக்கலாம்.

** மதிப்பீடு (Evaluation)
பகுப்பாய்வு மரவுருவை (Parse tree) மதிப்பிடுவதற்கு நாம் ஒரு தானழைப்பு
செயல்பாட்டை எழுதப் போகிறோம். ஆனால் நாம் தொடங்குவதற்கு முன், உள்ளீடாகப் பெறும்
மரவுருவின் கட்டமைப்பைப் பற்றி நாம் என்ன கவனிக்கலாம் என்பதைப் பார்ப்போம். முந்தைய
அத்தியாயத்திலிருந்து உங்கள் நிரலைப் பயன்படுத்தி சில வெளிப்பாடுகளை (expressions)
அச்சிட முயற்சிக்கவும். நீங்கள் என்ன கவனிக்கிறீர்கள்?

#+begin_example
lispy> * 10 (+ 1 51)
>
  regex
  operator|char:1:1 '*'
  expr|number|regex:1:3 '10'
  expr|>
    char:1:6 '('
    operator|char:1:7 '+'
    expr|number|regex:1:9 '1'
    expr|number|regex:1:11 '51'
    char:1:13 ')'
  regex
#+end_example

ஒரு கவனிப்பு என்னவென்றால், கணு (node) எண்ணுடன் குறியிடப்பட்டால் (tagged) அது
எப்போதும் எண்ணாகவே இருக்கும், குழந்தைகள் இல்லை, மேலும் உள்ளடக்கங்களை முழு எண்ணாக
(integer) மாற்றலாம். இது நமது தானழைப்பில் அடிப்படை வழக்காக (base case)
செயல்படும்.

ஒரு கணு expr உடன் குறியிடப்பட்டு, அது எண்ணாக இல்லாமல் இருந்தால், நாம் அதன்
இரண்டாவது குழந்தையைப் பார்க்க வேண்டும் (முதல் குழந்தை எப்போதும் '(') மற்றும் அது
எந்த செயலி என்று பார்க்கவும். மீதமுள்ள குழந்தைகளின் மதிப்பீட்டிற்கு இந்த செயலியைப்
பயன்படுத்த வேண்டும். இறுதிக் குழந்தையைத் தவிர இது எப்பொழுதும் ')' என்று இருக்கும்
. இது நம் தானழைப்பு வழக்கு (recursive case). வேர் கணுக்காகவும் (root node)
இதை செய்ய வேண்டும்.

நாம் நமது மரவுருவை மதிப்பிடும்போது, ​​கணுக்களை எண்ணுவதைப் போலவே, முடிவையும்
கூட்ட வேண்டும். இந்த முடிவைப் பிரதிநிதித்துவப்படுத்த (represent), சி வகை long
ஐ பயன்படுத்துவோம், அதாவது நீண்ட முழு எண்.

கணுவின் குறிச்சொல்லைக் கண்டறிய அல்லது கணுவிலிருந்து எண்ணைப் பெற, நாம் குறிச்சொல்
(tag) மற்றும் உள்ளடக்கப் (contents) புலங்களைப் (field) பயன்படுத்த வேண்டும். இவை
சரம் புலங்கள், எனவே நாம் முதலில் சில சரம் செயல்பாடுகளைக் கற்றுக்கொள்ள வேண்டும்.

| atoi   | ஒரு char*யை எண்ணாக மாற்றுகிறது.                                                                                                                                |
| strcmp | இரண்டு char* உள்ளீடாக எடுத்துக்கொள்கிறது மற்றும் அவை சமமாக இருந்தால் அது 0 ஐ வழங்கும்.                                                                             |
| strstr | இரண்டு char* உள்ளீடாக எடுத்துக்கொள்கிறது  மற்றும் முதல் சரத்தில் உள்ள இரண்டாவது சரத்தின் இடத்திற்கு ஒரு சுட்டியை வழங்குகிறது, அல்லது 0 என்றால் இரண்டாவது சரம் முதல் சரத்தின் துணைச் சரம் (sub string) அல்ல. |


எந்த செயலி (operator) பயன்படுத்த வேண்டும் என்பதைச் சரிபார்க்க strcmp ஐப்
பயன்படுத்தலாம், மேலும் ஒரு குறிச்சொல்லில் (tag) ஏதேனும் துணை சரம் உள்ளதா என்பதைச்
சரிபார்க்க strstr ஐப் பயன்படுத்தலாம். மொத்தத்தில் நம்முடைய தானழைப்பு மதிப்பீடு
செயல்பாடு இது போல் இருக்கும்.

#+begin_src c
  long eval(mpc_ast_t* t) {
  
    /* எண்ணாகக் குறிக்கப்பட்டிருந்தால், அதை நேரடியாகத் திருப்பி அனுப்பவும். */
    if (strstr(t->tag, "number")) {
      return atoi(t->contents);
    }
  
     /* செயலி (operator) எப்போதும் இரண்டாவது குழந்தை. */
    char* op = t->children[1]->contents;
  
    /* நாம் மூன்றாவது குழந்தையை `x` இல் சேமிக்கிறோம் */
    long x = eval(t->children[2]);
  
     /* மீதமுள்ள குழந்தைகளுக்கு திரும்பச்செய் (iterate) மற்றும் அதை இணை (combine). */
    int i = 3;
    while (strstr(t->children[i]->tag, "expr")) {
      x = eval_op(x, op, eval(t->children[i]));
      i++;
    }
  
    return x;
  }
#+end_src

eval_op செயல்பாட்டை நாம் பின்வருமாறு வரையறுக்கலாம். இது ஒரு எண், ஒரு செயலி
(operator) சரம் மற்றும் மற்றொரு எண்ணை உள்ளீடாக பெறும். எந்த செயலி (operator)
அனுப்பப்பட்டது என்பதைச் சோதித்து, உள்ளீடுகளுக்கு நிகரான சி செயல்பாட்டைச் செய்கிறது.

#+begin_src c
  /* எந்த செயல்பாட்டைச் செய்ய வேண்டும் என்பதைப் பார்க்க செயலி (operator) சரத்தைப் பயன்படுத்தவும் */
  long eval_op(long x, char* op, long y) {
    if (strcmp(op, "+") == 0) { return x + y; }
    if (strcmp(op, "-") == 0) { return x - y; }
    if (strcmp(op, "*") == 0) { return x * y; }
    if (strcmp(op, "/") == 0) { return x / y; }
    return 0;
  }
#+end_src

** அச்சிடுதல் (Printing)

மரவுருவை அச்சிடுவதற்கு பதிலாக, மதிப்பீட்டின் முடிவை அச்சிட
விரும்புகிறோம். எனவே, மரவுருவை நமது eval செயல்பாட்டிற்குள் அனுப்ப வேண்டும்,
மேலும் printf மற்றும் long வகைக்கு பயன்படுத்தப்படும் குறிப்பிட்ட %li ஐப்
பயன்படுத்தி நாம் பெறும் முடிவை அச்சிட வேண்டும்.

வெளியீடு மரவுரு (output tree) மதிப்பீடு செய்த பிறகு அதை நீக்க நினைவில் கொள்ள
வேண்டும்.

#+begin_src c
  long result = eval(r.output);
  printf("%li\n", result);
  mpc_ast_delete(r.output);
#+end_src

இவை அனைத்தும் வெற்றியடைந்தால், நமது புதிய நிரலாக்க மொழியில் சில அடிப்படைக்
கணிதங்களைச் செய்ய முடியும்!

#+begin_example
Lispy Version 0.0.0.0.3
Press Ctrl+c to Exit

lispy> + 5 6
11
lispy> - (* 10 10) (+ 1 1 1)
97
#+end_example

** வெகுமதி மதிப்பெண் (Bonus Marks)
- மரத்தின் இலைகளின் எண்ணிக்கையைக் கணக்கிட தானழைப்பு செயல்பாட்டை எழுதவும்.
- மரத்தின் கிளைகளின் எண்ணிக்கையைக் கணக்கிட தானழைப்பு செயல்பாட்டை எழுதவும்.
- ஒரு மரத்தின் ஒரு கிளையிலிருந்து அதிக எண்ணிக்கையிலான குழந்தைகளைக் கணக்கிடுவதற்கு தானழைப்பு செயல்பாட்டை எழுதவும்.
- கணு (node) expr எனக் குறிக்கப்பட்டுள்ளதா என்பதைப் பார்க்க strstr ஐ எவ்வாறு பயன்படுத்துவது?
- கணுவில் '(' அல்லது ')' உள்ளடக்கங்கள் உள்ளதா என்று பார்க்க strcmp ஐ எவ்வாறு பயன்படுத்துவது?
- செயலி % ஐச் சேர்க்கவும், இது மீதமுள்ள பிரிவை வழங்கும். உதாரணமாக % 10 6 என்பது 4 ஆகும்.
- செயலி சேர்க்கவும் ^, இது ஒரு எண்ணை மற்றொன்றுக்கு உயர்த்துகிறது. உதாரணமாக ^ 4 2 என்பது 16.
- மிகச்சிறிய எண்ணை வழங்கும் min செயல்பாட்டைச் சேர்க்கவும். உதாரணமாக min 1 5 3 என்பது 1 ஆகும்.
- அதிகபட்ச செயல்பாட்டைச் சேர்க்கவும், இது மிகப்பெரிய எண்ணை வழங்கும். எடுத்துக்காட்டாக, max 1 5 3 என்பது 5 ஆகும்.
- `-` செயலி மாற்றவும் - ஒரு தருமதிப்பு (argument) பெறும்போது அது எதிர்மறை எண்ணாக மாறும்.
