* அத்தியாயம் 7 - மதிப்பீடு (Evaluation)

** மரவுரு (Trees)

இப்போது நாம் உள்ளீட்டைப் (input) படித்து, அதை உள் கட்டமைத்துள்ளோம் (structured
internally), ஆனால் அதை இன்னும் மதிப்பீடு செய்ய முடியவில்லை. இந்த அத்தியாயத்தில்
அந்த கட்டமைப்பை மதிப்பிடும் குறியீடு சேர்ப்போம் மற்றும் கணக்கீடுகளை (computation)
நிகழ்த்துவோம்.

இந்த உள் கட்டமைப்புதான் முந்தைய அத்தியாயத்தில் நிரல் மூலம் அச்சிடப்பட்டதைப்
பார்த்தோம். இது ஒரு கருத்தியல் தொடரமைப்பு மரவுரு (Abstract Syntax Tree) என்று
அழைக்கப்படுகிறது, மேலும் இது பயனர் உள்ளீட்டின் அடிப்படையில் நிரலின் கட்டமைப்பைக்
குறிக்கிறது. இந்த மரத்தின் இலைகளில் எண்கள் மற்றும் செயலி (Operator) உள்ளன -
செயலாக்கப்பட வேண்டிய தரவு. கிளைகளில் மரத்தின் இந்தப் பகுதியை உற்பத்தி செய்யப்
பயன்படுத்தப்படும் விதிகள் உள்ளன - அதை எவ்வாறு கடந்து செல்வது (Traverse) மற்றும்
மதிப்பிடுவது (Evaluate) என்பது பற்றிய தகவல்கள்.

இதை எப்படி கடந்து செல்ல போகிறோம் என்பதைச் சரியாகச் செய்வதற்கு முன், இந்த அமைப்பு
எவ்வாறு உள் வரையறுக்கப்படுகிறது (internally defined) என்பதைப் பார்ப்போம். நாம்
mpc.h இன் உள்ளே எட்டிப்பார்த்தால், mpc_ast_t இன் வரையறையைப் (definition)
பார்க்கலாம், இது பாகுபாட்டிலிருந்து நமக்குக் கிடைத்த தரவுக் கட்டமைப்பாகும் (Data
structure).

#+begin_src c
  typedef struct mpc_ast_t {
    char* tag;
    char* contents;
    mpc_state_t state;
    int children_num;
    struct mpc_ast_t** children;
  } mpc_ast_t;
#+end_src

இந்த கட்டமைப்பில் நாம் அணுகக்கூடிய பல புலங்கள் (fields) உள்ளன. அவற்றை ஒவ்வொன்றாகப்
பார்ப்போம்.

முதல் புலம் (field) ~tag~. நாம் மரவுருவை (tree) அச்சிட்டபோது அது முனையின்
உள்ளடக்கத்திற்கு (contents) முந்தைய தகவல். அது குறிப்பிட்ட உருப்படியை (item)
பாகுபடுத்த பயன்படுத்தப்படும் அனைத்து விதிகளின் பட்டியலைக் கொண்ட ஒரு
சரம். உதாரணமாக expr|number|regex.

முனையை உருவாக்க என்ன பாகுபடுத்தும் விதிகள் பயன்படுத்தப்பட்டுள்ளன என்பதை அறிய,
இந்தக் ~tag~ புலம் முக்கியமானதாக இருக்கும்.

இரண்டாவது புலம் ~contents~. இது '*', '(' அல்லது '5' போன்ற முனையின் உள்ளபடி
உள்ளடக்கங்களைக் கொண்டிருக்கும். கிளைகளில் (branch) இது காலியாக இருப்பதை நீங்கள்
கவனிப்பீர்கள், ஆனால் இலைகளுக்குப் (leaf) பயன்படுத்துவதற்கான செயலி (operator)
அல்லது எண்ணைக் கண்டறிய இதைப் பயன்படுத்தலாம்.

அடுத்த புலம் ~state~. வரி மற்றும் நெடுவரிசை (column) எண் போன்ற இந்தக் கணுவைக்
(node) கண்டறிந்த போது பாகுபடுத்தி எந்த நிலையில் இருந்தது என்பது பற்றிய தகவல்
இதில் உள்ளது. நமது திட்டத்தில் (project) இதைப் பயன்படுத்த மாட்டோம்.

இறுதியாக மரவுருவில் கடந்து செல்ல உதவும் இரண்டு புலம்களைப் பார்க்கிறோம். இவை
~children_num~ மற்றும் ~children~. முதல் புலம் ஒரு கணுவுக்கு (node) எத்தனை
குழந்தைகள் என்று சொல்கிறது, இரண்டாவது இந்த குழந்தைகளின் அணி (Array).

~children~ புலத்தின் வகை mpc_ast_t**. இது இரட்டை சுட்டி வகை ஆகும். இது
தோற்றமளிப்பது போல் பயமாக இருக்காது மற்றும் அடுத்த அத்தியாயங்களில் இன்னும் விரிவாக
விளக்கப்படும். இப்போதைக்கு இதை இந்த மரவுருவின் குழந்தை கணுகளின் (node) பட்டியல்
(list) என்று நினைக்கலாம்.

அணி குறிமான முறையைப் (notation) பயன்படுத்தி இந்த புலத்தை அணுகுவதன் மூலம் நாம்
குழந்தை கணுவை (node) அணுகலாம். children என்ற புலப் பெயரை எழுதி, அதை
அணுகுவதற்கு குழந்தையின் சுட்டெண் (index) கொண்ட சதுர அடைப்புக்குறிகளுடன் (square
brackets) பின்னொட்டு (suffix) இடுவதன் மூலம் இது செய்யப்படுகிறது. உதாரணமாக
கணுவின் முதல் குழந்தையை அணுக நாம் children[0] என்று பயன்படுத்தலாம். சி அதன் அணி
சுட்டெண்களை (indices) 0 இலிருந்து கணக்கிடுகிறது என்பதைக் கவனியுங்கள்.

mpc_ast_t* வகை ஒரு structக்கான சுட்டிக்காட்டி என்பதால், அதன் புலங்களை (fields) அணுகுவதற்கு சற்று வித்தியாசமான தொடரியல் (syntax) உள்ளது. நாம் ஒரு புள்ளிக்குப் (dot .) பதிலாக ஒரு அம்புக்குறியைப் (arrow ->) பயன்படுத்த வேண்டும் இந்த செயலி (operator) மாறுதலுக்கு அடிப்படைக் காரணம் எதுவும் இல்லை, எனவே இப்போது சுட்டிக்காட்டி வகைகளின் புல (field) அணுகல் அம்புக்குறியைப் பயன்படுத்துகிறது என்பதை நினைவில் கொள்ளுங்கள்.

#+begin_src c
  /* வெளியீட்டிலிருந்து AST ஐ ஏற்றவும் */
mpc_ast_t* a = r.output;
printf("Tag: %s\n", a->tag);
printf("Contents: %s\n", a->contents);
printf("Number of children: %i\n", a->children_num);

/* முதல் குழந்தையைப் எடுங்கள் */
mpc_ast_t* c0 = a->children[0];
printf("First Child Tag: %s\n", c0->tag);
printf("First Child Contents: %s\n", c0->contents);
printf("First Child Number of children: %i\n",
  c0->children_num);
#+end_src

** தானழைப்பு (Recursion)

இந்த மரவுரு அமைப்பில் ஒரு வித்தியாசமான விஷயம் உள்ளது. அது தன்னையே குறிக்கிறது. அதன் ஒவ்வொரு குழந்தைகளும் மீண்டும் மரவுருக்களை குறிக்கும், அந்த குழந்தைகளின் குழந்தைகள் மீண்டும் மரவுருக்களை குறிக்கின்றது. நம் மொழிகள் மற்றும் மீண்டும் எழுதும் விதிகளைப் (re-write rules) போலவே, இந்தக் கட்டமைப்பில் (structure) உள்ள தரவு (data), அவர்களின் பெற்றோரை ஒத்த துணையமைப்புகளை (substructure) மீண்டும் கொண்டுள்ளது.

இந்த அமைப்பு (pattern) மீண்டும் மீண்டும் துணையமைப்புகளில் தொடரலாம். சாத்தியமான அனைத்து மரவுருக்களிலும் வேலை செய்யக்கூடிய ஒரு செயல்பாட்டை நாம் விரும்பினால், நாம் ஒரு ஜோடி கணுக்களை (nodes) மட்டும் கீழே பார்க்க முடியாது. மரவுருக்கள் எந்த ஆழத்திலும் வேலை செய்ய நாம் அதை வரையறுக்க (define) வேண்டும்.

அதிர்ஷ்டவசமாக, இந்த துணையமைப்புகள் எவ்வாறு மீண்டும் மீண்டும் வருகின்றன என்பதன் இயல்புகளைப் பயன்படுத்தி, தானழைப்பு (recursion) எனப்படும் வழிமுறையைப் பயன்படுத்துவதன் மூலம் இதைச் செய்யலாம்.

எளிமையாகச் சொன்னால், தானழைப்பு செயல்பாடு என்பது அதன் கணக்கீட்டின் (calculation) ஒரு பகுதியாக தன்னை அழைக்கும் ஒன்றாகும்.

ஒரு செயல்பாடு அதன் அடிப்படையில் வரையறுக்கப்படுவது விசித்திரமாகத் தெரிகிறது. ஆனால் செயல்பாடுகள் வெவ்வேறு உள்ளீடுகளுடன் வழங்கும்போது வெவ்வேறு வெளியீடுகளைக் கொடுக்க முடியும் என்பதைக் கவனியுங்கள். தானழைப்புக்கு மாற்றப்பட்ட அல்லது வெவ்வேறு உள்ளீடுகளை அதே செயல்பாட்டிற்கு வழங்கினால், மேலும் சில நிபந்தனைகளின் (conditions) கீழ் இந்தச் செயல்பாடு தன்னை மீண்டும் அழைக்காமல் இருப்பதற்கான வழியை வழங்கினால், இந்த தானழைப்பு செயல்பாடு பயனுள்ள ஒன்றைச் செய்கிறது என்பதில் நாம் அதிக நம்பிக்கையுடன் இருக்கலாம்.

தொடங்குவதற்கு முன், இது மிகவும் எளிமையான வழக்கில் எவ்வாறு செயல்படும் என்பதை நாம் கண்டுபிடிப்போம் - உள்ளீடு (input) மரவுருக்கு குழந்தைகள் இல்லை என்றால். இந்த விஷயத்தில் முடிவு ஒன்றுதான் என்பதை நாம் அறிவோம். இப்போது நாம் மிகவும் சிக்கலான வழக்கை வரையறுக்கலாம் - மரவுருவுக்கு ஒன்று அல்லது அதற்கு மேற்பட்ட குழந்தைகள் இருந்தால். இந்த வழக்கில் முடிவு ஒன்றாக இருக்கும் (கணுக்காகவே), அதனுடன் சேர்த்து அந்தக் குழந்தைகளில் உள்ள கணுக்களின் எண்ணிக்கை.

ஆனால் எல்லா குழந்தைகளிலும் உள்ள கணுக்களின் எண்ணிக்கையை எப்படி கண்டுபிடிப்பது? சரி நாம் வரையறுக்கும் செயல்பாட்டில் இருக்கும் செயல்பாட்டைப் பயன்படுத்தலாம்! ஆமாம், தானழைப்பு.

சி இல் நாம் இதை இப்படி எழுதலாம்.

#+begin_src c
int number_of_nodes(mpc_ast_t* t) {
  if (t->children_num == 0) { return 1; }
  if (t->children_num >= 1) {
    int total = 1;
    for (int i = 0; i < t->children_num; i++) {
      total = total + number_of_nodes(t->children[i]);
    }
    return total;
  }
  return 0;
}
#+end_src

தானழைப்பு செயல்பாடுகள் வித்தியாசமானவை, ஏனென்றால் அவற்றுக்கு கொஞ்சம் முரணான
நம்பிக்கை தேவை. முதலில் நாம் யூகிக்க வேண்டும் நம்மிடம் ஒரு செயல்பாடு உள்ளது, அது
ஏற்கனவே எதையாவது சரியாகச் செய்கிறது. பின்னர் இந்த செயல்பாட்டைப் பயன்படுத்தி, நாம்
நினைத்த ஆரம்ப (initial) செயல்பாட்டை எழுத வேண்டும்!

பெரும்பாலான விஷயங்களைப் போலவே, தானழைப்பு செயல்பாடுகளும் எப்போதும் ஒரே
மாதிரியான முறையைப் பின்பற்றுகின்றன. முதலில் ஒரு அடிப்படை நிலை (Base case)
வரையறுக்கப்படுகிறது. நமது முந்தைய எடுத்துக்காட்டில் t->children_num == 0 என்ற
நிலை (case) தானழைப்பை முடிவடைய செய்யும். இதற்குப் பிறகு, தானழைப்பு நிலை
(recursive case) வரையறுக்கப்படுகிறது, t->children_num >= 1 போன்று நமது
முந்தைய எடுத்துக்காட்டில், இது ஒரு கணக்கீட்டை சிறிய பகுதிகளாக உடைத்து, அவற்றை
ஒன்றாக இணைக்கும் முன், அந்த பகுதிகளை கணக்கிடுவதற்கு தன்னைத்தானே திரும்பத் திரும்ப
அழைக்கிறது.

தானழைப்பு செயல்பாடு புரிந்து கொள்வதற்கு சிறிது கணம் அகலம், எனவே இப்போது
இடைநிறுத்தப்பட்டு (pause), மற்ற அத்தியாயங்களில் தொடர்வதற்கு முன் அவற்றைப்
புரிந்துகொள்வதை உறுதிசெய்து கொள்ளுங்கள், ஏனென்றால் புத்தகத்தின் மற்ற பகுதிகளில்
அவற்றை நாம் அதிகமாக பயன்படுத்துவோம். நீங்கள் இன்னும் தானழைப்பில் உறுதியில்லாதவராக
இருந்தால், இந்த அத்தியாயத்திற்கான வெகுமதி மதிப்பெண்களில் (Bonus mark section)
சிலவற்றை முயற்சிக்கலாம்.

** மதிப்பீடு (Evaluation)
<h2 id='evaluation'>Evaluation</h2> <hr/>

<p>To evaluate the parse tree we are going to write a recursive function. But before we get started, let us try and see what observations we can make about the structure of the tree we get as input. Try printing out some expressions using your program from the previous chapter. What do you notice?</p>

<pre><code data-language='lispy'>lispy&gt; * 10 (+ 1 51)
&gt;
  regex
  operator|char:1:1 '*'
  expr|number|regex:1:3 '10'
  expr|&gt;
    char:1:6 '('
    operator|char:1:7 '+'
    expr|number|regex:1:9 '1'
    expr|number|regex:1:11 '51'
    char:1:13 ')'
  regex
</code></pre>

<p>One observation is that if a node is tagged with <code>number</code> it is always a number, has no children, and we can just convert the contents to an integer. This will act as the <em>base case</em> in our recursion.</p>

<p>If a node is tagged with <code>expr</code>, and is <em>not</em> a <code>number</code>, we need to look at its second child (the first child is always <code>'('</code>) and see which operator it is. Then we need to apply this operator to the <em>evaluation</em> of the remaining children, excluding the final child which is always <code>')'</code>. This is our <em>recursive case</em>. This also needs to be done for the root node.</p>

<p>When we evaluate our tree, just like when counting the nodes, we'll need to accumulate the result. To represent this result we'll use the C type <code>long</code> which means a <em>long</em> <em>integer</em>.</p>

<p>To detect the tag of a node, or to get a number from a node, we will need to make use of the <code>tag</code> and <code>contents</code> fields. These are <em>string</em> fields, so we are going to have to learn a couple of string functions first.</p>

<table class='table'>
  <tr><td><code>atoi</code></td><td>Converts a <code>char*</code> to a <code>int</code>.</td></tr>
  <tr><td><code>strcmp</code></td><td>Takes as input two <code>char*</code> and if they are equal it returns <code>0</code>.</td></tr>
  <tr><td><code>strstr</code></td><td>Takes as input two <code>char*</code> and returns a pointer to the location of the second in the first, or <code>0</code> if the second is not a sub-string of the first.</td></tr>
</table>

<p>We can use <code>strcmp</code> to check which operator to use, and <code>strstr</code> to check if a tag contains some substring. Altogether our recursive evaluation function looks like this.</p>

<pre><code data-language='c'>long eval(mpc_ast_t* t) {

  /* If tagged as number return it directly. */
  if (strstr(t-&gt;tag, "number")) {
    return atoi(t-&gt;contents);
  }

  /* The operator is always second child. */
  char* op = t-&gt;children[1]-&gt;contents;

  /* We store the third child in `x` */
  long x = eval(t-&gt;children[2]);

  /* Iterate the remaining children and combining. */
  int i = 3;
  while (strstr(t-&gt;children[i]-&gt;tag, "expr")) {
    x = eval_op(x, op, eval(t-&gt;children[i]));
    i++;
  }

  return x;
}</code></pre>

<p>We can define the <code>eval_op</code> function as follows. It takes in a number, an operator string, and another number. It tests for which operator is passed in, and performs the corresponding C operation on the inputs.</p>

<pre><code data-language='c'>/* Use operator string to see which operation to perform */
long eval_op(long x, char* op, long y) {
  if (strcmp(op, "+") == 0) { return x + y; }
  if (strcmp(op, "-") == 0) { return x - y; }
  if (strcmp(op, "*") == 0) { return x * y; }
  if (strcmp(op, "/") == 0) { return x / y; }
  return 0;
}</code></pre>

** அச்சிடுதல் (Printing)
<h2 id='printing'>Printing</h2> <hr/>

<p>Instead of printing the tree, we now want to print the result of the evaluation. Therefore we need to pass the tree into our <code>eval</code> function, and print the result we get using <code>printf</code> and the specifier <code>%li</code>, which is used for <code>long</code> type.</p>

<p>We also need to remember to delete the output tree after we are done evaluating it.</p>

<pre><code data-language='c'>long result = eval(r.output);
printf("%li\n", result);
mpc_ast_delete(r.output);</code></pre>

<p>If all of this is successful we should be able to do some basic maths with our new programming language!</p>

<pre><code data-language='lispy'>Lispy Version 0.0.0.0.3
Press Ctrl+c to Exit

lispy&gt; + 5 6
11
lispy&gt; - (* 10 10) (+ 1 1 1)
97</code></pre>


<h2>Reference</h2> <hr/>

<references />

** வெகுமதி மதிப்பெண் (Bonus Marks)
<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&rsaquo; Write a recursive function to compute the number of leaves of a tree.</li>
    <li class="list-group-item">&rsaquo; Write a recursive function to compute the number of branches of a tree.</li>
    <li class="list-group-item">&rsaquo; Write a recursive function to compute the most number of children spanning from one branch of a tree.</li>
    <li class="list-group-item">&rsaquo; How would you use <code>strstr</code> to see if a node was tagged as an <code>expr</code>?</li>
    <li class="list-group-item">&rsaquo; How would you use <code>strcmp</code> to see if a node had the contents <code>'('</code> or <code>')'</code>?</li>
    <li class="list-group-item">&rsaquo; Add the operator <code>%</code>, which returns the remainder of division. For example <code>% 10 6</code> is <code>4</code>.</li>
    <li class="list-group-item">&rsaquo; Add the operator <code>^</code>, which raises one number to another. For example <code>^ 4 2</code> is <code>16</code>.</li>
    <li class="list-group-item">&rsaquo; Add the function <code>min</code>, which returns the smallest number. For example <code>min 1 5 3</code> is <code>1</code>.</li>
    <li class="list-group-item">&rsaquo; Add the function <code>max</code>, which returns the biggest number. For example <code>max 1 5 3</code> is <code>5</code>.</li>
    <li class="list-group-item">&rsaquo; Change the minus operator <code>-</code> so that when it receives one argument it negates it.</li>
  </ul>
</div>


<h2>Navigation</h2>

<table class="table" style='table-layout: fixed;'>
  <tr>
    <td class="text-left"><a href="chapter6_parsing"><h4>&lsaquo; Parsing</h4></a></td>
    <td class="text-center"><a href="contents"><h4>&bull; Contents &bull;</h4></a></td>
    <td class="text-right"><a href="chapter8_error_handling"><h4>Error Handling &rsaquo;</h4></a></td>
  </tr>
</table>
