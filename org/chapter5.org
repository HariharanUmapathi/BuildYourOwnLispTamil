* அத்தியாயம் 5 - மொழிகள்(Languages)

** நிரலாக்க மொழி என்றால் என்ன?
ஒரு நிரலாக்க மொழி உண்மையான மொழி போல தான். இதற்குப் பின்னால் ஒரு அமைப்பு உள்ளது,
மேலும் சில விதிகள் உறுதிசெய்யும் எது சரி, எது சரி இல்லை என்று சொல்வது. நாம்
இயற்கை மொழியைப் படிக்கும்போதும் எழுதும்போதும், இந்த விதிகளை அறியாமலேயே
கற்றுக்கொள்கிறோம், நிரலாக்க மொழிகளுக்கும் இதுவே பொருந்தும். மற்றவர்களைப்
புரிந்துகொள்ளவும், நம்முடைய சொந்த பேச்சு அல்லது குறியீட்டை(Code) உருவாக்கவும் இந்த
விதிகளைப் பயன்படுத்தலாம்.

1950 களில் மொழியியலாளர் நோம் சாம்ஸ்கி (Noam Chomsky) மொழிகளைப் பற்றிய பல
முக்கியமான அவதானிப்புகளை (Observation) முறைப்படுத்தினார். இவற்றில் பல இன்று
மொழியைப் பற்றிய நமது புரிதலுக்கு அடிப்படையாக அமைகின்றன. இவற்றில் ஒன்று, இயற்கை
மொழிகள் மீள்சுருள் (Recursive) மற்றும் மீண்டும் மீண்டும் உட்கட்டமைப்புகளால்
(Substructures) கட்டமைக்கப்பட்டுள்ளன என்ற அவதானிப்பு.

இதற்கு உதாரணமாக, இந்த சொற்றொடரை நாம் ஆராயலாம்.

#+begin_example
The `cat` walked on the carpet.
#+end_example

ஆங்கில விதிகளைப் பயன்படுத்தி, பூனை என்ற பெயர்ச்சொல்லைப் (Noun) பிரிக்கப்பட்ட இரண்டு
பெயர்ச்சொற்களால் மாற்றலாம்.

#+begin_example
The `cat and dog` walked on the carpet.
#+end_example

இந்த புதிய பெயர்ச்சொற்கள் ஒவ்வொன்றும் மீண்டும் மாற்றப்படலாம். நாம் முன்பு இருந்த அதே
விதியைப் பயன்படுத்தலாம், மேலும் பூனைக்கு பதிலாக இரண்டு புதிய பெயர்ச்சொற்களை
இணைக்கலாம். அல்லது வேறு ஒரு விதியைப் பயன்படுத்தலாம் மற்றும் ஒவ்வொரு
பெயர்ச்சொற்களையும் ஒரு பெயரடை (Adjective) மற்றும் பெயர்ச்சொல்லுடன் மாற்றலாம்,
அவற்றுடன் விளக்கத்தைச் சேர்க்கலாம்.

#+begin_example
The `cat and mouse and dog` walked on the carpet.
#+end_example

#+begin_example
The `white cat and black dog` walked on the carpet.
#+end_example

இவை இரண்டு எடுத்துக்காட்டுகள் மட்டுமே, ஆனால் ஆங்கிலத்தில் சொற்களின் வகைகள் எவ்வாறு
மாற்றப்படலாம் மற்றும் கையாளப்படலாம் (Manipulate) என்பதற்கான பல்வேறு விதிகள் உள்ளன.

நிரலாக்க மொழிகளிலும் இந்த தன்மையை நம்மால் பார்க்கமுடிகிறது. சி இல், if
அறிக்கையின் உடல் புதிய அறிக்கைகளின் பட்டியலைக்(List) கொண்டுள்ளது. இந்த புதிய
அறிக்கைகள் ஒவ்வொன்றும், மற்றொரு அறிக்கையாக இருக்கலாம். இந்த தொடர்ச்சியான
கட்டமைப்புகள் மற்றும் மாற்றீடுகள்(replacement) மொழியின் அனைத்து பகுதிகளிலும்
பிரதிபலிக்கின்றன. இவை சில சமயங்களில் மீண்டும் எழுதும் விதிகள்(re-write rules)
என்று அழைக்கப்படுகின்றன, ஏனெனில் அவை ஒரு விஷயத்தை வேறு ஏதோவொன்றாக மீண்டும்
எழுதுவது எப்படி என்று உங்களுக்குச் சொல்கிறது.

#+begin_src c
if (x > 5) { return x; }
#+end_src

#+begin_src c
if (x > 5) { if (x > 10) { return x; } }
#+end_src

சாம்ஸ்கியின் இந்த அவதானிப்பின் விளைவு முக்கியமானது. ஒரு குறிப்பிட்ட மொழியில்
சொல்லக்கூடிய அல்லது எழுதப்பட்ட எண்ணற்ற(Infinite) பல்வேறு விஷயங்கள் இருந்தாலும்,
அவை அனைத்தையும் வரையறுக்கப்பட்ட எண்ணிக்கையிலான(Finite) மறு-எழுதுதல் விதிகள்
மூலம் செயல்படுத்தவும் புரிந்துகொள்ளவும் முடியும். மீண்டும் எழுதும்
விதிகளின்(Re-write rules) தொகுப்பிற்கு இலக்கணம்(Grammar) என்று பெயர்.

மீண்டும் எழுதும் விதிகளை நாம் பல வழிகளில் விவரிக்கலாம். ஒரு வழி
உரை(Textual). இப்படி ஏதாவது சொல்லலாம்
- ஒரு வாக்கியம்(Sentance)
  - ஒரு வினைச்சொல் சொற்றொடர்(verb phrase) ஆக இருக்க வேண்டும்.
  - ஒரு வினைச்சொல் சொற்றொடர் (verb phrase)
    - ஒரு வினைச்சொல்(verb) அல்லது
    - ஒரு வினையுரிச்சொல்(adverb) மற்றும் ஒரு வினைச்சொல்லாக(verb) இருக்கலாம்.
இந்த முறை மனிதர்களுக்கு புரியும், ஆனால் இது கணினிகளால் புரிந்து கொள்ள
முடியாதது. நிரலாக்கத்தின் போது ஒரு இலக்கணத்தின் முறையான விளக்கத்தை நாம் எழுத
வேண்டும்.

நாம் லிஸ்ப் போன்ற நிரலாக்க மொழியை எழுத நாம் இலக்கணங்களைப் புரிந்து கொள்ள
வேண்டும். பயனர் உள்ளிடை படிக்க, அதை விவரிக்கும் இலக்கணத்தை எழுத
வேண்டும். இலக்கணத்தை பயன்படுத்தி பயனர் உள்ளீடு செல்லுபடியாகுமா என்பதைத்
தீர்மானிக்கலாம். ஒரு கட்டமைக்கப்பட்ட(Structured) உள்(internal)
பிரதிநிதித்துவத்தை(representation) உருவாக்கவும் இதைப் பயன்படுத்தி அதைப்
புரிந்துகொள்வதையும் பின்னர் அதை மதிப்பிடுவதையும், குறியிடப்பட்ட(encoded)
கணக்கீடுகளைச்(computation) செய்வதையும் மிகவும் எளிதாக்கும்.

இங்குதான் mpc என்ற நூலகம் வருகிறது.

** பாகுபடுத்தி இணைப்பான்கள் (Parser Combinators)
<h2 id='parser_combinators'>Parser Combinators</h2> <hr/>

<p><code>mpc</code> is a <em>Parser Combinator</em> library I have written. This means it is a library that allows you to build programs that understand and process particular languages. These are known as <em>parsers</em>. There are many different ways of building parsers, but the cool thing about using a <em>Parser Combinator</em> library is that it lets you build <em>parsers</em> easily, just by specifying the <em>grammar</em> ... sort of.</p>

<p>Many Parser Combinator libraries actually work by letting you write normal code that <em>looks a bit like</em> a grammar, not by actually specifying a grammar directly. In many situations this is fine, but sometimes it can get clunky and complicated. Luckily for us <code>mpc</code> allows us to write normal code that just looks like a grammar, <em>or</em> we can use special notation to write a grammar directly!</p>

** குறியீட்டு இலக்கணங்கள் (Coding Grammers)
<h2 id='coding_grammars'>Coding Grammars</h2> <hr/>

<p>So what does code that looks like a grammar...<em>look like</em>? Let us take a look at <code>mpc</code> by trying to write code for a grammar that recognizes <a href="http://knowyourmeme.com/memes/doge">the language of Shiba Inu</a>. More colloquially known as <em>Doge</em>. This language we are going to define as follows.</p>

<p>&rsaquo; An <em>Adjective</em> is either <em>"wow"</em>, <em>"many"</em>, <em>"so"</em> or <em>"such"</em>.</p>
<p>&rsaquo; A <em>Noun</em> is either <em>"lisp"</em>, <em>"language"</em>, <em>"c"</em>, <em>"book"</em> or <em>"build"</em>.</p>
<p>&rsaquo; A <em>Phrase</em> is an <em>Adjective</em> followed by a <em>Noun</em>.</p>
<p>&rsaquo; A <em>Doge</em> is zero or more <em>Phrases</em>.</p>

<p>We can start by trying to define <em>Adjective</em> and <em>Noun</em>. To do this we create two new parsers, represented by the type <code>mpc_parser_t*</code>, and we store them in the variables <code>Adjective</code> and <code>Noun</code>. We use the function <code>mpc_or</code> to create a parser where one of several options should be used, and the function <code>mpc_sym</code> to wrap our initial strings.</p>

<p>If you squint you could attempt to read the code as if it were the rules we specified above.</p>

<pre><code data-language='c'>/* Build a parser 'Adjective' to recognize descriptions */
mpc_parser_t* Adjective = mpc_or(4,
  mpc_sym("wow"), mpc_sym("many"),
  mpc_sym("so"),  mpc_sym("such")
);

/* Build a parser 'Noun' to recognize things */
mpc_parser_t* Noun = mpc_or(5,
  mpc_sym("lisp"), mpc_sym("language"),
  mpc_sym("book"),mpc_sym("build"),
  mpc_sym("c")
);
</code></pre>

<div class="alert alert-warning">
  <p><strong>How can I access these <code>mpc</code> functions?</strong></p>

  <p>For now don't worry about compiling or running any of the sample code in this chapter. Just focus on understanding the theory behind grammars. In the next chapter we'll get set up with <code>mpc</code> and use it for a language closer to our Lisp.</p>
</div>

<p>To define <code>Phrase</code> we can reference our existing parsers. We need to use the function <code>mpc_and</code>, that specifies one thing is required then another. As input we pass it <code>Adjective</code> and <code>Noun</code>, our previously defined parsers. This function also takes the arguments <code>mpcf_strfold</code> and <code>free</code>, which say how to join or delete the results of these parsers. Ignore these arguments for now.</p>

<pre><code data-language='c'>mpc_parser_t* Phrase = mpc_and(2, mpcf_strfold,
  Adjective, Noun, free);</code></pre>

<p>To define <em>Doge</em> we must specify that <em>zero or more</em> of some parser is required. For this we need to use the function <code>mpc_many</code>. As before, this function requires the special variable <code>mpcf_strfold</code> to say how the results are joined together, which we can ignore.</p>

<pre><code data-language='c'>mpc_parser_t* Doge = mpc_many(mpcf_strfold, Phrase);</code></pre>

<p>By creating a parser that looks for <em>zero or more</em> occurrences of another parser an interesting thing has happened. Our <code>Doge</code> parser accepts inputs of any length. This means its language is <em>infinite</em>. Here are just some examples of possible strings <code>Doge</code> could accept. Just as we discovered in the first section of this chapter we have used a finite number of re-write rules to create an infinite language.</p>

<pre><code data-language='c'>"wow book such language many lisp"
"so c such build such language"
"many build wow c"
""
"wow lisp wow c many language"
"so c"
</code></pre>

<p>If we use more <code>mpc</code> functions, we can slowly build up parsers that parse more and more complicated languages. The code we use <em>sort of</em> reads like a grammar, but becomes much more messy with added complexity. Due to this, taking this approach isn't always an easy task. A whole set of helper functions that build on simple constructs to make frequent tasks easy are all documented on the <a href="http://github.com/orangeduck/mpc">mpc repository</a>. This is a good approach for complicated languages, as it allows for fine-grained control, but won't be required for our needs.</p>

** இயற்கை இலக்கணங்கள் (Natural Grammers)
<h2 id='natural_grammars'>Natural Grammars</h2> <hr/>

<p><code>mpc</code> lets us write grammars in a more natural form too. Rather than using C functions that look less like a grammar, we can specify the whole thing in one long string. When using this method we don't have to worry about how to join or discard inputs, with functions such as <code>mpcf_strfold</code>, or <code>free</code>. All of that is done automatically for us.</p>

<p>Here is how we would recreate the previous examples using this method.</p>

<pre><code data-language='c'>mpc_parser_t* Adjective = mpc_new("adjective");
mpc_parser_t* Noun      = mpc_new("noun");
mpc_parser_t* Phrase    = mpc_new("phrase");
mpc_parser_t* Doge      = mpc_new("doge");

mpca_lang(MPCA_LANG_DEFAULT,
  "                                           \
    adjective : \"wow\" | \"many\"            \
              |  \"so\" | \"such\";           \
    noun      : \"lisp\" | \"language\"       \
              | \"book\" | \"build\" | \"c\"; \
    phrase    : &lt;adjective&gt; &lt;noun&gt;;           \
    doge      : &lt;phrase&gt;*;                    \
  ",
  Adjective, Noun, Phrase, Doge);

/* Do some parsing here... */

mpc_cleanup(4, Adjective, Noun, Phrase, Doge);
</code></pre>

<p>Without having an exact understanding of the syntax for that long string, it should be obvious how much <em>clearer</em> the grammar is in this format. If we learn what all the special symbols mean we barely need to squint.</p>

<p>Another thing to notice is that the process is now in two steps. First we create and name several rules using <code>mpc_new</code> and then we define them using <code>mpca_lang</code>.</p>

<p>The first argument to <code>mpca_lang</code> are the options flags. For this we just use the defaults. The second is a long multi-line string in C. This is the <em>grammar</em> specification. It consists of a number of <em>re-write rules</em>. Each rule has the name of the rule on the left, a colon <code>:</code>, and on the right its definition terminated with a semicolon <code>;</code>.</p>

<p>The special symbols used to define the rules on the right hand side work as follows.</p>

<table class='table'>
  <tr><td><code>"ab"</code></td><td>The string <code>ab</code> is required.</td></tr>
  <tr><td><code>'a'</code></td><td>The character <code>a</code> is required.</td></tr>
  <tr><td><code>'a' 'b'</code></td><td>First <code>'a'</code> is required, then <code>'b'</code> is required.</td></tr>
  <tr><td><code>'a' | 'b'</code></td><td>Either <code>'a'</code> is required, or <code>'b'</code> is required.</td></tr>
  <tr><td><code>'a'*</code></td><td>Zero or more <code>'a'</code> are required.</td></tr>
  <tr><td><code>'a'+</code></td><td>One or more <code>'a'</code> are required.</td></tr>
  <tr><td><code>&lt;abba&gt;</code></td><td>The rule called <code>abba</code> is required.</td></tr>
</table>

<div class="alert alert-warning">
  <p><strong>Sounds familiar...</strong></p>

  <p>Did you notice that the description of what the input string to <code>mpca_lang</code> should look like sounded like I was specifying a grammar? That's because it was. <code>mpc</code> uses itself internally to parse the input you give it to <code>mpca_lang</code>. It does it by specifying a <em>grammar</em> in code using the previous method. How neat is that?</p>
</div>

<p>Using the table described above verify that what I've written above is equal to what we specified in code.</p>

<p>This method of specifying a grammar is what we are going to use in the following chapters. It might seem overwhelming at first. Grammars can be difficult to understand. But as we continue you will become much more familiar with how to create and edit them.</p>

<p>This chapter is about theory, so if you are going to try some of the bonus tasks, don't worry too much about correctness. Thinking in the right mindset is more important. Feel free to invent symbols and notation for certain concepts to make them simpler to write down. Some of the bonus task also might require cyclic or recursive grammar structures, so don't worry if you have to use these!</p>



** வெகுமதி மதிப்பெண் (Bonus Marks)
<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&rsaquo; Write down some more examples of strings the <code>Doge</code> language contains.</li>
    <li class="list-group-item">&rsaquo; Why are there back slashes <code>\</code> in front of the quote marks <code>"</code> in the grammar?</li>
    <li class="list-group-item">&rsaquo; Why are there back slashes <code>\</code> at the end of the line in the grammar?</li>
    <li class="list-group-item">&rsaquo; Describe textually a grammar for decimal numbers such as <code>0.01</code> or <code>52.221</code>.</li>
    <li class="list-group-item">&rsaquo; Describe textually a grammar for web URLs such as <code>http://www.buildyourownlisp.com</code>.</li>
    <li class="list-group-item">&rsaquo; Describe textually a grammar for simple English sentences such as <code>the cat sat on the mat</code>.</li>
    <li class="list-group-item">&rsaquo; Describe more formally the above grammars. Use <code>|</code>, <code>*</code>, or any symbols of your own invention.</li>
    <li class="list-group-item">&rsaquo; If you are familiar with JSON, textually describe a grammar for it.</li>
  </ul>
</div>


