* அத்தியாயம் 5 - மொழிகள்(Languages)

** நிரலாக்க மொழி என்றால் என்ன?
ஒரு நிரலாக்க மொழி உண்மையான மொழி போல தான். இதற்குப் பின்னால் ஒரு அமைப்பு உள்ளது,
மேலும் சில விதிகள் உறுதிசெய்யும் எது சரி, எது சரி இல்லை என்று சொல்வது. நாம்
இயற்கை மொழியைப் படிக்கும்போதும் எழுதும்போதும், இந்த விதிகளை அறியாமலேயே
கற்றுக்கொள்கிறோம், நிரலாக்க மொழிகளுக்கும் இதுவே பொருந்தும். மற்றவர்களைப்
புரிந்துகொள்ளவும், நம்முடைய சொந்த பேச்சு அல்லது குறியீட்டை(Code) உருவாக்கவும் இந்த
விதிகளைப் பயன்படுத்தலாம்.

1950 களில் மொழியியலாளர் நோம் சாம்ஸ்கி (Noam Chomsky) மொழிகளைப் பற்றிய பல
முக்கியமான அவதானிப்புகளை (Observation) முறைப்படுத்தினார். இவற்றில் பல இன்று
மொழியைப் பற்றிய நமது புரிதலுக்கு அடிப்படையாக அமைகின்றன. இவற்றில் ஒன்று, இயற்கை
மொழிகள் மீள்சுருள் (Recursive) மற்றும் மீண்டும் மீண்டும் உட்கட்டமைப்புகளால்
(Substructures) கட்டமைக்கப்பட்டுள்ளன என்ற அவதானிப்பு.

இதற்கு உதாரணமாக, இந்த சொற்றொடரை நாம் ஆராயலாம்.

#+begin_example
The `cat` walked on the carpet.
#+end_example

ஆங்கில விதிகளைப் பயன்படுத்தி, பூனை என்ற பெயர்ச்சொல்லைப் (Noun) பிரிக்கப்பட்ட இரண்டு
பெயர்ச்சொற்களால் மாற்றலாம்.

#+begin_example
The `cat and dog` walked on the carpet.
#+end_example

இந்த புதிய பெயர்ச்சொற்கள் ஒவ்வொன்றும் மீண்டும் மாற்றப்படலாம். நாம் முன்பு இருந்த அதே
விதியைப் பயன்படுத்தலாம், மேலும் பூனைக்கு பதிலாக இரண்டு புதிய பெயர்ச்சொற்களை
இணைக்கலாம். அல்லது வேறு ஒரு விதியைப் பயன்படுத்தலாம் மற்றும் ஒவ்வொரு
பெயர்ச்சொற்களையும் ஒரு பெயரடை (Adjective) மற்றும் பெயர்ச்சொல்லுடன் மாற்றலாம்,
அவற்றுடன் விளக்கத்தைச் சேர்க்கலாம்.

#+begin_example
The `cat and mouse and dog` walked on the carpet.
#+end_example

#+begin_example
The `white cat and black dog` walked on the carpet.
#+end_example

இவை இரண்டு எடுத்துக்காட்டுகள் மட்டுமே, ஆனால் ஆங்கிலத்தில் சொற்களின் வகைகள் எவ்வாறு
மாற்றப்படலாம் மற்றும் கையாளப்படலாம் (Manipulate) என்பதற்கான பல்வேறு விதிகள் உள்ளன.

நிரலாக்க மொழிகளிலும் இந்த தன்மையை நம்மால் பார்க்கமுடிகிறது. சி இல், if
அறிக்கையின் உடல் புதிய அறிக்கைகளின் பட்டியலைக்(List) கொண்டுள்ளது. இந்த புதிய
அறிக்கைகள் ஒவ்வொன்றும், மற்றொரு அறிக்கையாக இருக்கலாம். இந்த தொடர்ச்சியான
கட்டமைப்புகள் மற்றும் மாற்றீடுகள்(replacement) மொழியின் அனைத்து பகுதிகளிலும்
பிரதிபலிக்கின்றன. இவை சில சமயங்களில் மீண்டும் எழுதும் விதிகள்(re-write rules)
என்று அழைக்கப்படுகின்றன, ஏனெனில் அவை ஒரு விஷயத்தை வேறு ஏதோவொன்றாக மீண்டும்
எழுதுவது எப்படி என்று உங்களுக்குச் சொல்கிறது.

#+begin_src c
if (x > 5) { return x; }
#+end_src

#+begin_src c
if (x > 5) { if (x > 10) { return x; } }
#+end_src

சாம்ஸ்கியின் இந்த அவதானிப்பின் விளைவு முக்கியமானது. ஒரு குறிப்பிட்ட மொழியில்
சொல்லக்கூடிய அல்லது எழுதப்பட்ட எண்ணற்ற(Infinite) பல்வேறு விஷயங்கள் இருந்தாலும்,
அவை அனைத்தையும் வரையறுக்கப்பட்ட எண்ணிக்கையிலான(Finite) மறு-எழுதுதல் விதிகள்
மூலம் செயல்படுத்தவும் புரிந்துகொள்ளவும் முடியும். மீண்டும் எழுதும்
விதிகளின்(Re-write rules) தொகுப்பிற்கு இலக்கணம்(Grammar) என்று பெயர்.

மீண்டும் எழுதும் விதிகளை நாம் பல வழிகளில் விவரிக்கலாம். ஒரு வழி
உரை(Textual). இப்படி ஏதாவது சொல்லலாம்
- ஒரு வாக்கியம்(Sentance)
  - ஒரு வினைச்சொல் சொற்றொடர்(verb phrase) ஆக இருக்க வேண்டும்.
  - ஒரு வினைச்சொல் சொற்றொடர் (verb phrase)
    - ஒரு வினைச்சொல்(verb) அல்லது
    - ஒரு வினையுரிச்சொல்(adverb) மற்றும் ஒரு வினைச்சொல்லாக(verb) இருக்கலாம்.
இந்த முறை மனிதர்களுக்கு புரியும், ஆனால் இது கணினிகளால் புரிந்து கொள்ள
முடியாதது. நிரலாக்கத்தின் போது ஒரு இலக்கணத்தின் முறையான விளக்கத்தை நாம் எழுத
வேண்டும்.

நாம் லிஸ்ப் போன்ற நிரலாக்க மொழியை எழுத நாம் இலக்கணங்களைப் புரிந்து கொள்ள
வேண்டும். பயனர் உள்ளிடை படிக்க, அதை விவரிக்கும் இலக்கணத்தை எழுத
வேண்டும். இலக்கணத்தை பயன்படுத்தி பயனர் உள்ளீடு செல்லுபடியாகுமா என்பதைத்
தீர்மானிக்கலாம். ஒரு கட்டமைக்கப்பட்ட(Structured) உள்(internal)
பிரதிநிதித்துவத்தை(representation) உருவாக்கவும் இதைப் பயன்படுத்தி அதைப்
புரிந்துகொள்வதையும் பின்னர் அதை மதிப்பிடுவதையும், குறியிடப்பட்ட(encoded)
கணக்கீடுகளைச்(computation) செய்வதையும் மிகவும் எளிதாக்கும்.

இங்குதான் mpc என்ற நூலகம் வருகிறது.

** பாகுபடுத்தி இணைப்பான்கள் (Parser Combinators)
mpc என்பது நான் எழுதிய ஒரு பாகுபடுத்தி இணைப்பான்கள் நூலகம். அதாவது, குறிப்பிட்ட
மொழிகளைப் புரிந்துகொள்ளும் மற்றும் செயலாக்கும்(process) நிரல்களை உருவாக்க உங்களை
அனுமதிக்கும் நூலகம் இது. இவை பாகுபடுத்திகள் எனப்படும். பாகுபடுத்திகளை உருவாக்க
பல்வேறு வழிகள் உள்ளன, ஆனால் பாகுபடுத்தி இணைப்பான்கள் நூலகம் பயன்படுத்துவதில் சிறந்த
விஷயம் என்னவென்றால், இலக்கணத்தைக் குறிப்பிடுவதன் மூலம் பாகுபடுத்திகளை எளிதாக
உருவாக்க இது உங்களை அனுமதிக்கிறது.

பல பாகுபடுத்தி இணைப்பான் நூலகங்கள் உண்மையில் ஒரு இலக்கணத்தைப் போலவே தோற்றமளிக்கும்
சாதாரண குறியீட்டை எழுத அனுமதிப்பதன் மூலம் செயல்படுகின்றன, உண்மையில் இலக்கணத்தை
நேரடியாகக் குறிப்பிடுவதில்லை. பல சூழ்நிலைகளில் இது நன்றாக இருக்கிறது, ஆனால்
சில நேரங்களில் அது குழப்பமாகவும் சிக்கலாகவும் இருக்கலாம். அதிர்ஷ்டவசமாக mpc ஆனது
ஒரு இலக்கணத்தைப் போன்று தோற்றமளிக்கும் சாதாரண குறியீட்டை எழுத அனுமதிக்கிறது
அல்லது இலக்கணத்தை நேரடியாக எழுத சிறப்பு குறியீட்டைப் பயன்படுத்துகிறது!

** குறியீட்டு இலக்கணங்கள் (Coding Grammers)

அப்படியென்றால் இலக்கணம் போல இருக்கும் குறியீடு... எப்படி இருக்கும்? [[https://knowyourmeme.com/memes/doge][ஷிபா இனுவின்]]
(Shiba Inu) மொழியை அங்கீகரிக்கும் இலக்கணத்திற்கான குறியீட்டை எழுத முயற்சிப்பதன்
மூலம் mpc ஐப் பார்ப்போம். மேலும் பேச்சுவழக்கில் டோஜ் (Doge) என்று
அழைக்கப்படுகிறது. இந்த மொழியை நாம் பின்வருமாறு வரையறுக்கப் போகிறோம்.

#+begin_quote
ஒரு பெயரடை(Adjective) என்பது "wow", "many", "so" அல்லது "such".
#+end_quote

#+begin_quote
ஒரு பெயர்ச்சொல்(Noun) என்பது "lisp", "language", "c", "book" அல்லது "build".
#+end_quote

#+begin_quote
ஒரு சொற்றொடர் என்பது ஒரு பெயரடை தொடர்ந்து பெயர்சொல்.
#+end_quote

#+begin_quote
ஒரு Doge என்பது பூஜ்ஜியம் அல்லது அதற்கு மேற்பட்ட சொற்றொடர்கள்
#+end_quote

பெயரடை மற்றும் பெயர்ச்சொல்லை வரையறுக்க(define) முயற்சிப்பதன் மூலம்
தொடங்கலாம். இதைச் செய்ய, mpc_parser_t* வகையால் குறிப்பிடப்படும் இரண்டு புதிய
பாகுபடுத்திகளை உருவாக்கி, அவற்றை மாறிகளில் Adjective மற்றும் Noun என்று
சேமித்து வைக்கிறோம். mpc_or செயல்பாட்டைப் பயன்படுத்தி, பல விருப்பங்களில் ஒன்றைப்
பயன்படுத்த வேண்டிய ஒரு பாகுபடுத்தியை உருவாக்குவோம், மேலும் mpc_sym செயல்பாட்டை
நாம் ஆரம்ப சரங்களை(String) மடி(wrap) செய்ய பயன்படுத்துகிறோம்.

நீங்கள் முன்பு குறிப்பிட்ட விதிகளைப் போலவே குறியீட்டைப் படிக்க முயற்சி செய்யலாம்.

#+begin_src c
/* விளக்கங்களை அடையாளம் காண ஒரு பாகுபடுத்தி 'Adjective' உருவாக்கவும் */
mpc_parser_t* Adjective = mpc_or(4,
  mpc_sym("wow"), mpc_sym("many"),
  mpc_sym("so"),  mpc_sym("such")
);

/* விளக்கங்களை அடையாளம் காண ஒரு பாகுபடுத்தி 'Noun' உருவாக்கவும் */
mpc_parser_t* Noun = mpc_or(5,
  mpc_sym("lisp"), mpc_sym("language"),
  mpc_sym("book"),mpc_sym("build"),
  mpc_sym("c")
);

#+end_src

- இந்த mpc செயல்பாடுகளை நான் எவ்வாறு அணுகுவது?
  - இப்போதைக்கு இந்த அத்தியாயத்தில் உள்ள மாதிரிக் குறியீட்டை நிரல்மொழிமாற்றுவது
    அல்லது இயக்குவது பற்றி கவலைப்பட வேண்டாம். இலக்கணங்களுக்குப் பின்னால் உள்ள
    கோட்பாட்டைப் புரிந்துகொள்வதில் கவனம் செலுத்துங்கள். அடுத்த அத்தியாயத்தில், mpc
    உடன் எப்படி அமைத்து, லிஸ்ப் போன்ற ஒரு மொழியை உருவாக்க இதைப் பயன்படுத்தவும்.

Phrase வரையறுக்க, நாம் ஏற்கனவே உள்ள பாகுபடுத்திகளைக் குறிப்பிடலாம். நாம்
mpc_and செயல்பாட்டைப் பயன்படுத்தி, அது ஒரு விஷயம் தேவை பிறகு மற்றொன்று என்பதை
குறிப்பிடுகிறது. நாம் Adjective மற்றும் Noun னை உள்ளீடாக(input) mpc_and கு
அனுப்புகிறோம், முன்னர் வரையறுக்கப்பட்ட பகுபடுத்தி. mpc_and செயல்பாடு
mpcf_strfold மற்றும் free வாதங்களையும்(Argument) எடுக்கும், இது இந்த
பாகுபடுத்திகளின் முடிவுகளை(results) எவ்வாறு சேர்ப்பது அல்லது நீக்குவது என்று
கூறுகிறது. இப்போதைக்கு mpcf_strfold மற்றும் free என்ற வாதங்களை புறக்கணிக்கவும்.

#+begin_src c
  mpc_parser_t* Phrase = mpc_and(2, mpcf_strfold, Adjective, Noun, free);
#+end_src

Doge ஐ வரையறுக்க, சில பாகுபடுத்திகளில் பூஜ்ஜியம் அல்லது அதற்கு மேற்பட்டவை தேவை
என்பதைக் குறிப்பிட வேண்டும். இதற்கு நாம் mpc_many என்ற செயல்பாட்டைப் பயன்படுத்த
வேண்டும். முன்பு போலவே, இந்தச் செயல்பாட்டிற்கு mpcf_strfold என்ற சிறப்பு மாறி,
முடிவுகள் எவ்வாறு ஒன்றாக இணைக்கப்படுகின்றன என்பதைக் கூறகிறது, mpcf_strfold நாம்
இப்போதைக்கு புறக்கணிக்கலாம்.

#+begin_src c
  mpc_parser_t* Doge = mpc_many(mpcf_strfold, Phrase);
#+end_src

ஒரு பாகுபடுத்தியை உருவாக்கி அது பூஜ்ஜியம் அல்லது அதற்கு மேற்பட்ட நிகழ்வுகளைத்
தேடும் மற்றொரு பாகுபடுத்தியை உருவாக்குவதன் மூலம் ஒரு சுவாரஸ்யமான விஷயம்
ஏற்படும். நாம் Doge பாகுபடுத்தி எந்த (any) நீள (length) உள்ளீடுகளையும்
ஏற்றுக்கொள்கிறது. இதன் பொருள் இந்த மொழி(Doge) எல்லையற்றது (Infinite). Doge
ஏற்றுக்கொள்ளக்கூடிய சாத்தியமான சரங்களின் சில எடுத்துக்காட்டுகள் இங்கே உள்ளன. இந்த
அத்தியாயத்தின் முதல் பகுதியில் நாம் கண்டுபிடித்தது போலவே, எல்லையற்ற மொழியை
உருவாக்க, வரையறுக்கப்பட்ட எண்ணிக்கையிலான மறு எழுதும் விதிகளைப்
பயன்படுத்தியுள்ளோம்.

#+begin_example
"wow book such language many lisp"
"so c such build such language"
"many build wow c"
""
"wow lisp wow c many language"
"so c"
#+end_example

நாம் அதிக mpc செயல்பாடுகளைப் பயன்படுத்தினால், மேலும் மேலும் சிக்கலான மொழிகளைப்
பாகுபடுத்தும் பாகுபடுத்திகளை மெதுவாக உருவாக்கலாம்.நாம் பயன்படுத்தும் குறியீடானது
ஒரு இலக்கணத்தைப் போன்றது, ஆனால் கூடுதல் சிக்கலுடன்(complexity) மிகவும்
குழப்பமாகிறது. இதன் காரணமாக, இந்த அணுகுமுறையை எடுத்துக்கொள்வது எப்போதும்
எளிதான காரியம் அல்ல. அடிக்கடி செய்யும் பணிகளை எளிதாக்குவதற்கு எளிய
கட்டுமானங்களில் உருவாக்கப்படும் Helper செயல்பாடுகளின் முழு தொகுப்பும் [[https://github.com/orangeduck/mpc][mpc
களஞ்சியத்தில்]] ஆவணப்படுத்தப்பட்டுள்ளது. சிக்கலான மொழிகளுக்கு இது ஒரு நல்ல
அணுகுமுறையாகும், ஏனெனில் இது நுணுக்கமான கட்டுப்பாட்டை அனுமதிக்கிறது, ஆனால்
நமது தேவைகளுக்கு இது தேவையில்லை.

** இயற்கை இலக்கணங்கள் (Natural Grammers)

mpc இலக்கணங்களை மிகவும் இயற்கையான வடிவத்தில் எழுத அனுமதிக்கிறது. இலக்கணத்தைப்
போல தோற்றமளிக்கும் சி செயல்பாடுகளைப் பயன்படுத்துவதற்குப் பதிலாக, முழு
விஷயத்தையும் ஒரு நீண்ட சரத்தில் (String) குறிப்பிடலாம். இந்த முறையைப் பயன்படுத்தும்
போது, ​​mpcf_strfold அல்லது free போன்ற செயல்பாடுகளுடன் உள்ளீடுகளை எவ்வாறு
சேர்ப்பது அல்லது நிராகரிப்பது என்பது பற்றி நாம் கவலைப்பட வேண்டியதில்லை. அதெல்லாம்
நமக்கு தானாக நிகழ்கிறது.

இந்த முறையைப் பயன்படுத்தி முந்தைய உதாரணங்களை எவ்வாறு மீண்டும் உருவாக்குவது என்பது
இங்கே.

#+begin_src c
  mpc_parser_t* Adjective = mpc_new("adjective");
  mpc_parser_t* Noun      = mpc_new("noun");
  mpc_parser_t* Phrase    = mpc_new("phrase");
  mpc_parser_t* Doge      = mpc_new("doge");
  
  mpca_lang(MPCA_LANG_DEFAULT,
    "                                           \
      adjective : \"wow\" | \"many\"            \
                |  \"so\" | \"such\";           \
      noun      : \"lisp\" | \"language\"       \
                | \"book\" | \"build\" | \"c\"; \
      phrase    : <adjective> <noun>;           \
      doge      : <phrase>*;                    \
    ",
    Adjective, Noun, Phrase, Doge);
  
  /* Do some parsing here... */
  
  mpc_cleanup(4, Adjective, Noun, Phrase, Doge);
#+end_src

அந்த நீண்ட சரத்திற்கான (String) தொடரியல் (Syntax) பற்றிய சரியான புரிதல்
இல்லாமல், இந்த வடிவத்தில் இலக்கணம் எவ்வளவு தெளிவாக உள்ளது என்று உங்களுக்கே
புரியும். அனைத்து சிறப்பு (Special) குறியீடு (Symbol) எதைக் குறிக்கின்றன
என்பதை நாம் கற்றுக்கொண்டால், நாம் கண்களை இமைக்கும் நேரத்தில் செய்யலாம்.

கவனிக்க வேண்டிய மற்றொரு விஷயம் என்னவென்றால், செயல்முறை (process) இப்போது இரண்டு
படிகளில் உள்ளது. முதலில் mpc_new ஐப் பயன்படுத்தி பல விதிகளை உருவாக்கி
பெயரிடுவோம், பின்னர் அவற்றை mpca_lang ஐப் பயன்படுத்தி வரையறுக்கிறோம் (define).

mpca_langக்கான முதல் வாதம் (argument) விருப்பங்கள் கொடிகள் (flag). இதற்கு நாம்
இயல்புநிலைகளை (defaults) மட்டுமே பயன்படுத்துகிறோம். இரண்டாவது சி இல் ஒரு நீண்ட
பல வரி சரம் (multi line string). இது இலக்கண விவரக்குறிப்பு
(specification). இது பல மீண்டும் எழுதும் விதிகளைக் கொண்டுள்ளது. ஒவ்வொரு
விதிக்கும் இடதுபுறத்தில் (left) விதியின் பெயர் உள்ளது, பின்பு முக்காற்புள்ளி (: -
colon), மற்றும் வலதுபுறத்தில் (right) அதன் வரையறை (definition)
அரைப்புள்ளியுடன் (; - semicolon) நிறுத்தப்பட்டது.

வலது புறத்தில் உள்ள விதிகளை வரையறுக்கப் பயன்படுத்தப்படும் சிறப்பு குறியீடுகள்
பின்வருமாறு செயல்படுகின்றன.

| "ab"    | சரம் ab தேவை.                           |
| 'a'     | எழுத்து தேவை.                           |
| 'a' 'b' | முதலில் 'a' தேவை, பிறகு 'b' தேவை.      |
|  ~'a' | 'b'~       | ஒன்று 'a' தேவை, அல்லது 'b' தேவை.      |
| 'a'*    | பூஜ்யம் அல்லது அதற்கு மேற்பட்ட 'a' தேவை. |
| 'a'+    | ஒன்று அல்லது அதற்கு மேற்பட்ட 'a' தேவை.  |
| <abba>  | <abba> என்ற விதி தேவை.                  |


- பரிச்சியமாக இருக்கிறதா...
  - mpca_langக்கான உள்ளீட்டு சரம் எப்படி இருக்க வேண்டும் என்பதற்கான விளக்கம் நாம்
    இலக்கணத்தைக் குறிப்பிடுவது போல் இருப்பதை நீங்கள் கவனித்தீர்களா? ஏனென்றால் அது
    இலக்கணம் தான். mpca_langக்கு நீங்கள் கொடுக்கும் உள்ளீட்டை பாகுபடுத்த mpc தான்
    உள்ளே பயன்படுத்துகிறது. முந்தைய முறையைப் பயன்படுத்தி குறியீட்டில் இலக்கணத்தைக்
    குறிப்பிடுவதன் மூலம் இது செய்கிறது. அது எவ்வளவு நேர்த்தியானது?

மேலே விவரிக்கப்பட்ட அட்டவணையைப் பயன்படுத்தி, நான் மேலே எழுதியது குறியீட்டில் நாம்
குறிப்பிட்டதற்குச் சமம் (equal) என்பதைச் சரிபார்க்கவும்.

இலக்கணத்தைக் குறிப்பிடும் இந்த முறையைத்தான் பின்வரும் அத்தியாயங்களில் பயன்படுத்தப்
போகிறோம். இது முதலில் பெரியதாக தோன்றலாம். இலக்கணங்களைப் புரிந்துகொள்வது
கடினம். ஆனால் நாம் தொடரும்போது (continue), ​​அவற்றை எவ்வாறு உருவாக்குவது மற்றும்
திருத்துவது என்பதை நாம் நன்கு அறிந்துகொள்வோம்.

இந்த அத்தியாயம் கோட்பாட்டைப் பற்றியது, எனவே நீங்கள் வெகுமதி பணிகளை முயற்சிக்கப்
போகிறீர்கள் என்றால், சரியானதைப் பற்றி அதிகம் கவலைப்பட வேண்டாம். சரியான மனநிலையில்
சிந்திப்பது மிகவும் முக்கியம். தயங்காமல், சில கருத்துக்களுக்கான குறியீடுகளையும்
குறிப்பையும் கண்டுபிடித்து அவற்றை எளிதாக எழுதலாம். வெகுமதி பணிகளில்
சிலவற்றிற்கு வட்டமான (cyclic) அல்லது மீள்சுருள் (recursive) இலக்கண கட்டமைப்புகள்
தேவைப்படலாம், எனவே நீங்கள் இவற்றைப் பயன்படுத்தினால் அதை பற்றி அதிகம் கவலைப்பட
வேண்டாம்!

** வெகுமதி மதிப்பெண் (Bonus Marks)
<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&rsaquo; Write down some more examples of strings the <code>Doge</code> language contains.</li>
    <li class="list-group-item">&rsaquo; Why are there back slashes <code>\</code> in front of the quote marks <code>"</code> in the grammar?</li>
    <li class="list-group-item">&rsaquo; Why are there back slashes <code>\</code> at the end of the line in the grammar?</li>
    <li class="list-group-item">&rsaquo; Describe textually a grammar for decimal numbers such as <code>0.01</code> or <code>52.221</code>.</li>
    <li class="list-group-item">&rsaquo; Describe textually a grammar for web URLs such as <code>http://www.buildyourownlisp.com</code>.</li>
    <li class="list-group-item">&rsaquo; Describe textually a grammar for simple English sentences such as <code>the cat sat on the mat</code>.</li>
    <li class="list-group-item">&rsaquo; Describe more formally the above grammars. Use <code>|</code>, <code>*</code>, or any symbols of your own invention.</li>
    <li class="list-group-item">&rsaquo; If you are familiar with JSON, textually describe a grammar for it.</li>
  </ul>
</div>


